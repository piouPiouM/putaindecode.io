<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[putaindecode.io]]></title><description><![CDATA[putaindecode.io]]></description><link>http://putaindecode.io</link><generator>RSS for Node</generator><lastBuildDate>Fri, 17 Jun 2016 12:33:30 GMT</lastBuildDate><atom:link href="http://putaindecode.io/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Pourquoi j'ai arrêté d'utiliser CSS]]></title><description><![CDATA[<p>CSS est un langage horriblement dangereux, parce qu&#x27;il mêle des concepts complètement pétés et une folle capacité à faire confondre facilité et simplicité aux gens qui l&#x27;utilisent.</p>
<h2 id="quest-ce-qui-ne-va-pas-"><a href="#quest-ce-qui-ne-va-pas-" class="phenomic-HeadingAnchor">#</a>Qu&#x27;est-ce qui ne va pas ?</h2>
<p>À l&#x27;origine, CSS a été conçu pour styler des documents, pas des applications. Du coup lorsqu&#x27;on doit <em>scale</em>, c&#x27;est rapidement douloureux.</p>
<h3 id="les-sélecteurs"><a href="#les-s%C3%A9lecteurs" class="phenomic-HeadingAnchor">#</a>Les sélecteurs</h3>
<p>Les sélecteurs sont des <strong>variables globales mutables</strong>. Lorsque vous faites :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.selector</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>;
}</code></pre>
<p>C&#x27;est comme si en JavaScript vous faisiez :</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">window</span>.selector = (<span class="hljs-built_in">window</span>.selector || []).concat({
  fontSize: <span class="hljs-string">"1rem"</span>,
})</code></pre>
<p>Ça veut dire que :</p>
<ul>
<li>La définition d&#x27;un style associé à un sélecteur peut être redéfinie ailleurs</li>
<li>Si on associe plusieurs styles à un sélecteur, les derniers définis dans le CSS auront toujours la priorité</li>
<li>Quelqu&#x27;un peut péter les styles d&#x27;un composant pour peu qu&#x27;il ne sache pas qu&#x27;un sélecteur est utilisé ailleurs</li>
</ul>
<h3 id="la-spécificité"><a href="#la-sp%C3%A9cificit%C3%A9" class="phenomic-HeadingAnchor">#</a>La spécificité</h3>
<p>Alors ça, c&#x27;est particulièrement drôle : la spécificité d&#x27;un sélecteur va définir la priorité d&#x27;application d&#x27;un style.</p>
<table>
<thead>
<tr>
<th>Sélecteur</th>
<th>Spécificité</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>0,0,0,0</td>
</tr>
<tr>
<td><code>li</code></td>
<td>0,0,0,1</td>
</tr>
<tr>
<td><code>li:first-line</code></td>
<td>0,0,0,2</td>
</tr>
<tr>
<td><code>ul li</code></td>
<td>0,0,0,2</td>
</tr>
<tr>
<td><code>ul ol+li</code></td>
<td>0,0,0,3</td>
</tr>
<tr>
<td><code>h1 + *[rel=up]</code></td>
<td>0,0,1,1</td>
</tr>
<tr>
<td><code>ul ol li.red</code></td>
<td>0,0,1,3</td>
</tr>
<tr>
<td><code>li.red.level</code></td>
<td>0,0,2,1</td>
</tr>
<tr>
<td><code>#x34y</code></td>
<td>0,1,0,0</td>
</tr>
</tbody>
</table>
<p>Si le style est défini dans l&#x27;attribut <code>style</code>, la spécificité est de 1,0,0,0. Si une valeur associée à une propriété est suffixée d&#x27;un <code>!important</code>, elle prend quoi qu&#x27;il arrive l&#x27;ascendance.</p>
<p>Si on résume, on nage en plein délire, la priorité se définit dans l&#x27;ordre par : la présence de <code>!important</code>, la façon de définir le style, la spécificité du sélecteur utilisé puis par l&#x27;ordre de définition dans l&#x27;ensemble des CSS de la page. Évidemment, à l&#x27;époque où on n&#x27;avait qu&#x27;une pauvre petite feuille de style pour l&#x27;ensemble de son site, ça marchait ; plus maintenant.</p>
<h3 id="les-régressions"><a href="#les-r%C3%A9gressions" class="phenomic-HeadingAnchor">#</a>Les régressions</h3>
<p>Prenons un exemple tout bête :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.item</span> {
  <span class="hljs-attribute">display</span>: block;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">color</span>: blue;
}

<span class="hljs-selector-class">.some-context</span> <span class="hljs-selector-class">.item</span> {
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>Quelqu&#x27;un de la team modifie <code>.item</code> :</p>
<pre><code class="hljs language-diff"> .item {
   display: block;
   font-size: 1rem;
   color: blue;
<span class="hljs-addition">+  border: 1px solid red;</span>
 }

 .some-context .item {
   display: inline-block;
   color: red;
}</code></pre>
<p>Super, une regression dans <code>some-context</code>. Face à ça, deux possibilités :</p>
<ul>
<li>Vous vous foutez d&#x27;avoir des régressions qui pètent votre site</li>
<li>À chaque changement minime du CSS vous vérifiez l&#x27;intégralité du site et testez tous les comportements dans tous les contextes.</li>
</ul>
<h3 id="le-choix-de-priorisation-des-styles"><a href="#le-choix-de-priorisation-des-styles" class="phenomic-HeadingAnchor">#</a>Le choix de priorisation des styles</h3>
<p>Ce serait pas mal de décider quel <code>className</code> est appliqué en priorité :</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"blue red"</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"red blue"</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>mais bien évidemment non, comme vu plus haut, c&#x27;est le foutu ordre de définition des sélecteurs qui décide. Je vous laisse imaginer le bordel si on charge les feuilles de style à la demande, selon les actions utilisateur.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.blue</span> { <span class="hljs-attribute">color</span>: blue; }
<span class="hljs-selector-class">.red</span> { <span class="hljs-attribute">color</span>: red; }</code></pre>
<p>C&#x27;est pire si vous utilisez un préprocesseur tel que Sass et LESS. Lorsque vous faites un :</p>
<pre><code class="hljs language-css">.blue {
  color: blue;
}

.red {
  color: red;
}

.my-selector {
  @extend .red;
  @extend .blue;
}</code></pre>
<p>Vous imaginez que <code>.blue</code> étant appliqué après dans <code>.my-selector</code>, il va prendre la priorité. EH BAH NON, c&#x27;est <code>.red</code>, parce que sa déclaration est située après <code>.blue</code>.</p>
<p>Si ce constat peut aussi permettre à ceux et celles qui utilisent des CSS atomiques d&#x27;arrêter immédiatement :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.relative</span> { <span class="hljs-attribute">position</span>: relative; }
<span class="hljs-selector-class">.absolute</span> { <span class="hljs-attribute">position</span>: absolute; }
<span class="hljs-selector-class">.static</span> { <span class="hljs-attribute">position</span>: static; }</code></pre>
<p>Dans le cas précédent, si vous ajoutez une classe <code>relative</code> à un élement ayant déjà la classe <code>static</code>, ça ne changera rien du tout, parce que <code>.static</code> est défini après <code>.relative</code>. Génial, non ?</p>
<h3 id="le-futur-de-css"><a href="#le-futur-de-css" class="phenomic-HeadingAnchor">#</a>Le futur de CSS</h3>
<p>Les variables sont une feature qui a été très demandée à CSS. Mais cette feature va débarquer avec son lot de souci :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attribute">--mainColor</span>: blue;
}

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--mainColor);
}</code></pre>
<p>C&#x27;est super, mais si quelqu&#x27;un vient ajouter :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attribute">--mainColor</span>: red;
}</code></pre>
<p>quelque part, il y a deux cas :</p>
<ul>
<li>soit c&#x27;est chargé avant, et ça ne fait rien</li>
<li>soit c&#x27;est chargé après, et ça override toutes les propriétés utilisant <code>--mainColor</code>. On est bien contents.</li>
</ul>
<h2 id="vous-ne-pouvez-pas-vous-permettre-de-laisser-tomber-css-"><a href="#vous-ne-pouvez-pas-vous-permettre-de-laisser-tomber-css-" class="phenomic-HeadingAnchor">#</a>Vous ne pouvez pas vous permettre de laisser tomber CSS ?</h2>
<p>Dans ce cas, forcez vous à utiliser la <a href="/fr/articles/css/bem/">méthodologie BEM</a>. Ça ne réglera pas tout, mais au moins cela vous permettra d&#x27;éviter un maximum de conneries en vous forçant à découper en composants isolés, et à mieux maîtriser la priorisation, puisque le scope auquel vous devrez y veiller sera considérablement réduit :</p>
<pre><code class="hljs language-css"><span class="hljs-comment">/* Header.css */</span>
<span class="hljs-selector-class">.Header</span> {}

  <span class="hljs-selector-class">.Header-nav</span> {}

<span class="hljs-comment">/* Nav.css */</span>
<span class="hljs-selector-class">.Nav</span> {}

  <span class="hljs-selector-class">.Nav-item</span> {}

    <span class="hljs-selector-class">.Nav-item--active</span> {}</code></pre>
<p>C&#x27;est quand même plus pratique à comprendre, non ?</p>
<p>Encore mieux, si vous avez du tooling à la webpack, vous pouvez utiliser les <a href="/fr/articles/css/modules/">CSS modules</a>, qui limiteront de même le scope d&#x27;application de vos feuilles de style.</p>
<h2 id="vous-pouvez-vous-permettre-de-laisser-tomber-css-"><a href="#vous-pouvez-vous-permettre-de-laisser-tomber-css-" class="phenomic-HeadingAnchor">#</a>Vous pouvez vous permettre de laisser tomber CSS ?</h2>
<p>JavaScript vous permet déjà de bénéficier d&#x27;un système de modules, de variables, de conditions, de fonctions réutilisables, et tout ça sans hack. En plus de ça, vous maitrisez la priorisation, parce c&#x27;est que c&#x27;est vous qui décidez ce qui s&#x27;applique :</p>
<pre><code class="hljs language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> { active, disabled } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">...styles.myComponent</span>,
          <span class="hljs-attr">...active</span> ? <span class="hljs-attr">styles.active</span> <span class="hljs-attr">:</span> <span class="hljs-attr">null</span>,
          <span class="hljs-attr">...disabled</span> &amp;&amp; !<span class="hljs-attr">active</span> ? <span class="hljs-attr">styles.disabled</span> <span class="hljs-attr">:</span> <span class="hljs-attr">null</span>,
        }}
      &gt;</span>
        tadaa
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">const</span> styles = {
  myComponent: {
    fontSize: <span class="hljs-number">18</span>,
  },
  active: {
    textDecoration: <span class="hljs-string">"underline"</span>,
  },
  disabled: {
    opacity: <span class="hljs-number">0.5</span>,
  },
}</code></pre>
<p>Par ailleurs, avec certaines bibliothèques permettant naturellement l&#x27;usage d&#x27;inline-styles (comme React), cela vous donne la possibilité d&#x27;avoir le style et le markup dans le même fichier, sans avoir besoin de naviguer entre les onglets de votre éditeur (vous pouvez cependant séparer en plusieurs fichiers si ça vous fait plaisir).</p>
<p>En résumé, utiliser JS pour définir et appliquer les styles vous permet de prendre le contrôle sur le styling de vos composants, tout en apportant le confort d&#x27;un langage offrant naturellement de nombreux avantages. Si vous êtes bloqués avec CSS, partez sur les CSS modules ou la méthologie BEM selon vos possibilités. Le but, c&#x27;est d&#x27;éliminer les <a href="https://github.com/necolas/react-native-web/blob/master/docs/guides/style.md">7 maux de CSS</a>.</p>
<p>Bisous bisous.</p>
]]></description><link>http://putaindecode.io/fr/articles/css/stop-css/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/css/stop-css/</guid><pubDate>Thu, 16 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Les patterns Provider & Higher-Order Component avec React]]></title><description><![CDATA[<h2 id="le-pattern-provider"><a href="#le-pattern-provider" class="phenomic-HeadingAnchor">#</a>Le pattern provider</h2>
<p>Beaucoup de bibliotèques React ont besoin de faire passer des data au travers de tout l&#x27;arbre de composants de votre app. Par exemple Redux a besoin de passer son <em>store</em> et React Router doit passer l&#x27;objet <em>location</em>. Tout ça pourrait possiblement passer par du <em>shared mutable state</em> (état global mutable, ce qui est rarement une bonne idée). Le <em>shared mutable state</em> rend impossible une application à plus d&#x27;un contexte. En d&#x27;autres mots, ça ne marcherait que sur le client, où l&#x27;état global correspond à celui de l&#x27;utilisateur. Si vous décidez de rendre la page côté serveur, c&#x27;est impossible de reposer sur une telle implémentation : cet état ne doit pas dépasser le scope de la requête courante au serveur.</p>
<p>Coup de bol, l&#x27;API de React nous offre une solution à ce problème: le <a href="http://facebook.github.io/react/docs/context.html"><code>context</code></a>. Si l&#x27;on résume sa nature, c&#x27;est comme l&#x27;objet global de votre arbre de composants.</p>
<p>Le <code>context</code> fonctionne de la façon suivante:</p>
<ul>
<li>On définit haut dans notre app un <code>context</code> que l&#x27;on donne aux composants descendants de l&#x27;app</li>
<li>On récupère ce contexte dans les composants descendants.</li>
</ul>
<p>Du coup, pour <em>donner</em> ce <code>context</code>, on doit avoir un <code>Provider</code>. Son rôle est simplement de fournir un <code>context</code> pour que les composants enfants y aient accès.</p>
<p>On va illustrer ce pattern avec un use-case très simple : dans notre app, les utilisateurs peuvent customiser le thème.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> React, { Component, PropTypes, Children } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThemeProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// la méthode getChildContext est appelée pour fournir le `context`</span>
  <span class="hljs-comment">// dans notre cas, on le récupère des `props`</span>
  getChildContext() {
    <span class="hljs-keyword">return</span> {
      theme: <span class="hljs-keyword">this</span>.props.theme,
    }
  }
  <span class="hljs-comment">// on render l'enfant</span>
  render() {
    <span class="hljs-keyword">return</span> Children.only(<span class="hljs-keyword">this</span>.props.children)
  }
}

ThemeProvider.propTypes = {
  theme: PropTypes.object.isRequired,
}

<span class="hljs-comment">// pour que React prenne en compte le context fourni,</span>
<span class="hljs-comment">// on doit définir les types des propriétés que l'on passe</span>
ThemeProvider.childContextTypes = {
  theme: PropTypes.object.isRequired,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ThemeProvider</code></pre>
<p>Pour utiliser le provider, il suffit de wrapper notre app avec:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>

<span class="hljs-keyword">import</span> ThemeProvider <span class="hljs-keyword">from</span> <span class="hljs-string">"ThemeProvider"</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"App"</span>

<span class="hljs-keyword">const</span> theme = {
  color: <span class="hljs-string">"#cc3300"</span>,
  fontFamily: <span class="hljs-string">"Georgia"</span>,
}

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">{theme}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#App"</span>)
)</code></pre>
<p>Maintenant que notre <code>theme</code> est bien ajouté au <code>context</code>, on a besoin d&#x27;un moyen simple pour que nos composants dans l&#x27;app puissent le consommer. Ça nous amène au second pattern.</p>
<h2 id="le-pattern-higher-order-component"><a href="#le-pattern-higher-order-component" class="phenomic-HeadingAnchor">#</a>Le pattern Higher-Order Component</h2>
<p>Afin de consommer le <code>context</code>, un component doit définir une propriété statique <code>contextTypes</code> stipulant quelles propriétés le composant souhaite récupérer. On pourrait le définir sur chaque composant, mais cela serait une mauvaise idée pour deux raisons :</p>
<ul>
<li><strong>La maintenabilité</strong> : si à un moment, on a besoin de refacto, avoir tous ces <code>contextTypes</code> éparpillés dans notre repository peut faire bien mal.</li>
<li><strong>La complexité</strong>: L&#x27;API des <code>context</code> étant encore obscure pour beaucoup, il est préférable de faire une abstraction pour la masquer.</li>
</ul>
<p>Une autre solution serait d&#x27;utiliser l&#x27;héritage d&#x27;une sous-classe de <code>ReactComponent</code>. Ça ne marche pas pour deux raisons:</p>
<ul>
<li>Plus d&#x27;un niveau d&#x27;héritage est en général une idée de merde. Cela mène souvent à des conflits entre méthodes, et force à vérifier toute la chaîne d&#x27;héritage à chaque fois que l&#x27;on souhaite modifier quelque chose. L&#x27;API des <code>mixins</code> de <code>React.createClass</code> réglait ce souci en définissant des comportements de merge selon les méthodes, mais cela rend encore plus obscure la compréhension du fonctionnement de nos composants.</li>
<li>Si l&#x27;on veut des APIs <strong>interopérables</strong>, on ne peut pas partir de l&#x27;héritage. React offre trois moyens de définir un composant: <code>class extends React.Component {}</code>, <code>React.createClass({})</code> et <code>(props) =&gt; ReactElement</code>. Les deux derniers ne peuvent pas bénéficier de l&#x27;héritage.</li>
</ul>
<p>La meilleure façon de créer une fonctionnalité réutilisable est d&#x27;utiliser le pattern du <strong>Higher Order Component</strong> (ou <em>HOC</em>). Ce que ça veut dire, c&#x27;est qu&#x27;on va simplement wrapper un composant dans un autre, lequel a pour unique rôle d&#x27;injecter la fonctionnalité et de la passer via les <code>props</code>. Il s&#x27;agit tout bêtement du principe de composition : au lieu d&#x27;exporter <code>A</code>, vous exportez <code>Wrapped(A)</code>, et ce dernier retourne un composant React qui va appeler <code>A</code> dans sa méthode <code>render</code>.</p>
<p>Pour le voir simplement, il s&#x27;agit d&#x27;un point intermédiaire dans l&#x27;arbre de vos composants, qui injecte quelques <code>props</code>. Il existe beaucoup d&#x27;avantages apportés par ce pattern :</p>
<ul>
<li><strong>Isolation</strong> : Il n&#x27;y a pas de risque de collision de propriétés au sein du composant.</li>
<li><strong>Interopérabilité</strong> : Ce principe s&#x27;adapte à tout composant React, peu importe la façon dont il a été défini.</li>
<li><strong>Maintenabilité</strong> : Le wrapper n&#x27;aura qu&#x27;une seule fonctionnalité, ce qui le rend plus simple à comprendre. De plus, si l&#x27;on utilise le <code>context</code>, on ne trouvera le mapping <code>contextTypes</code> qu&#x27;à un seul endroit dans l&#x27;app.</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> React, { Component, PropTypes } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-keyword">const</span> themed = (ComponentToWrap) =&gt; {
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThemeComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    render() {
      <span class="hljs-keyword">const</span> { theme } = <span class="hljs-keyword">this</span>.context
      <span class="hljs-comment">// le component va render `ComponentToWrap`</span>
      <span class="hljs-comment">// mais il va y ajouter la prop `theme`, qu'il récupère du `context`</span>
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentToWrap</span> {…<span class="hljs-attr">this.props</span>} <span class="hljs-attr">theme</span>=<span class="hljs-string">{theme}</span> /&gt;</span>
      )
    }
  }
  // on définit ce qu'on veut consommer du `context`
  ThemeComponent.contextTypes = {
    theme: PropTypes.object.isRequired,
  }

  // on retourne notre wrapper
  return ThemeComponent
}
export default themed</span></code></pre>
<p>Pour utiliser notre HOC, il suffira d&#x27;exporter nos composants wrappés :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"React"</span>
<span class="hljs-keyword">import</span> theme <span class="hljs-keyword">from</span> <span class="hljs-string">"theme"</span>

<span class="hljs-keyword">const</span> MyStatelessComponent = ({ text, theme }) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.color</span> }}&gt;</span>
    {text}
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> themed(MyStatelessComponent)</code></pre>
<p>Puisqu&#x27;il s&#x27;agit simplement d&#x27;une fonction, on peut y passer des options à l&#x27;aide d&#x27;une simple closure.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> defaultMergeProps = (ownProps, themeProps) =&gt; ({  ...ownProps, ...themeProps })

<span class="hljs-keyword">const</span> theme = (mergeProps = defaultMergeProps) =&gt;
  (ComponentToWrap) =&gt; {
    <span class="hljs-comment">// …</span>
    render() {
      <span class="hljs-keyword">const</span> { theme } = <span class="hljs-keyword">this</span>.context
      <span class="hljs-keyword">const</span> props = mergeProps(<span class="hljs-keyword">this</span>.props, { theme })
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentToWrap</span> {…<span class="hljs-attr">props</span>} /&gt;</span>
      )
    }
    // …
  }</span></code></pre>
<p>et l&#x27;utiliser de cette façon :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> mergeProps = (ownProps, themeProps) =&gt; ({ ...themeProps, color: themeProps.theme.color })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> theme(mergeProps)(MyComponent)</code></pre>
<p>Une astuce sympathique lorsque vous utilisez plusieurs HOC, c&#x27;est de les composer, puisque <code>compose(A, B, C)(props)</code> vaudra <code>A(B(C(props)))</code>, par exemple :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> composed = compose(
  connect(mapStateToProps),
  theme()
)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> composed(MyComponent)</code></pre>
<p>Bisous bisous.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/react/higher-order-component/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/react/higher-order-component/</guid><pubDate>Tue, 14 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Redux, comment ça marche ?]]></title><description><![CDATA[<p>Alors si vous faites du développement web et que vous ne vivez pas dans une cave, vous avez certainement déjà entendu parler de <a href="http://redux.js.org">Redux</a>.</p>
<h2 id="kesako-"><a href="#kesako-" class="phenomic-HeadingAnchor">#</a>Kesako ?</h2>
<p>Redux est une implémentation dérivée de Flux. Ça permet de créer un <strong>Store</strong> qui contient un <strong>état</strong>, réagit à des <strong>actions dispatchées</strong>, et auquel on peut <strong>souscrire</strong> pour être notifié des changements. Il permet également l&#x27;ajout de <strong>middlewares</strong>, qui peuvent en quelque sorte <em>pre-process</em> les actions.</p>
<p>Du coup, on va écrire une implémentation de Redux pour mieux décomposer son fonctionnement.</p>
<h2 id="1-gérer-létat"><a href="#1-g%C3%A9rer-l%C3%A9tat" class="phenomic-HeadingAnchor">#</a>1. Gérer l&#x27;état</h2>
<p>Redux se distingue par son mécanisme d&#x27;update de l&#x27;état, puisqu&#x27;il est décrit dans des <strong>reducers</strong>. Vous connaissez <a href="/fr/articles/js/array-reduce/"><code>Array.prototype.reduce</code></a> ? Eh ben votre <strong>reducer</strong> a exactement la même signature que la fonction de <code>reduce</code>.</p>
<p>Pour faire simple, votre état vaudra toujours :</p>
<pre><code class="hljs language-javascript">dispatchedActions.reduce(reducer, <span class="hljs-literal">undefined</span>)</code></pre>
<p>Si ça vous paraît un peu abstrait, prenons un exemple tout con de reducer :</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// on part de 0</span>
<span class="hljs-keyword">const</span> initialState = { counter: <span class="hljs-number">0</span> }

<span class="hljs-keyword">const</span> counter = (state = initialState, action) =&gt; {
  <span class="hljs-keyword">switch</span>(action.type) {
    <span class="hljs-comment">// selon l'action …</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"INCREMENT"</span>:
      <span class="hljs-comment">// … on retourne un nouvel état incrémenté</span>
      <span class="hljs-keyword">return</span> { counter: state.counter + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">case</span> <span class="hljs-string">"DECREMENT"</span>:
      <span class="hljs-comment">// … ou décrémenté</span>
      <span class="hljs-keyword">return</span> { counter: state.counter - <span class="hljs-number">1</span> }
    <span class="hljs-keyword">default</span>:
      <span class="hljs-comment">// ou l'état actuel, si l'on n'y touche pas</span>
      <span class="hljs-keyword">return</span> state
  }
}</code></pre>
<p>Le petit <code>state = initialState</code> c&#x27;est un <a href="/fr/articles/js/es2015/defaults/">paramètre avec une valeur par défaut</a>, si vous avez bien vu le bout de code avec le <code>reduce</code> un peu plus haut, on passe la valeur <code>undefined</code> comme accumulateur initial, ça permet d&#x27;avoir un state valant <code>initialState</code> au passage de la première action.</p>
<p>Le <code>switch</code> permet de retourner un nouvel état selon les actions passées, avec un <code>default</code> qui retourne l&#x27;état actuel, dans le cas où on se fout de l&#x27;action dans ce reducer.</p>
<p>C&#x27;est parti pour implémenter ça :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> createStore = (reducer) =&gt; {
  <span class="hljs-comment">// on balance une première action "opaque",</span>
  <span class="hljs-comment">// qui ne sera pas traitée par le reducer, histoire de commencer avec un état</span>
  <span class="hljs-keyword">let</span> state = reducer(<span class="hljs-literal">undefined</span>, { type: <span class="hljs-string">"@@INIT"</span> })
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// une méthode pour dispatcher les actions</span>
    dispatch: (action) =&gt; {
      state = reducer(state, action)
    },
    <span class="hljs-comment">// une méthode pour récupérer le state</span>
    getState: () =&gt; state
  }
}</code></pre>
<p>Super, on peut écrire et lire notre état.</p>
<h2 id="2-le-mécanisme-de-souscription"><a href="#2-le-m%C3%A9canisme-de-souscription" class="phenomic-HeadingAnchor">#</a>2. Le mécanisme de souscription</h2>
<p>Pour pouvoir signaler aux intéressés que des updates ont eu lieu sur l&#x27;état, on doit ajouter un mécanisme de souscription : un bête event emitter.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> createStore = (reducer) =&gt; {
  <span class="hljs-keyword">let</span> state = reducer(<span class="hljs-literal">undefined</span>, { type: <span class="hljs-string">"@@INIT"</span> })
  <span class="hljs-comment">// on crée un `Set` où l'on va stocker les listeners</span>
  <span class="hljs-keyword">const</span> subscribers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
  <span class="hljs-keyword">return</span> {
    dispatch: (action) =&gt; {
      state = reducer(state, action)
      <span class="hljs-comment">// à chaque dispatch, on appelle les subscribers</span>
      subscribers.forEach((func) =&gt; func())
    },
    subscribe: (func) =&gt; {
      <span class="hljs-comment">// on ajoute `func` à la liste de subscribers</span>
      subscribers.add(func)
      <span class="hljs-comment">// et on retourne une fonction permettant d'unsubscribe</span>
      <span class="hljs-keyword">return</span> () =&gt; {
        subscribers.delete(func)
      }
    },
    getState: () =&gt; state
  }
}</code></pre>
<p>Ayé, le mécanisme est en place.</p>
<h2 id="3-combiner-les-reducers"><a href="#3-combiner-les-reducers" class="phenomic-HeadingAnchor">#</a>3. Combiner les reducers</h2>
<p>Maintenant ce qui serait pas mal, ce serait de permettre d&#x27;avoir plusieurs reducers, afin de pouvoir les découper et d&#x27;éviter d&#x27;avoir du gros code bloated qui tâche. Pour ce faire, on va créer la fonction <code>combineReducers</code> qui va prendre un objet contenant des reducers, et transformer ça en un seul reducer qui va retourner un objet de la même forme, avec l&#x27;état retourné par le reducer de la même clé.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> combineReducers = (reducers) =&gt; {
  <span class="hljs-keyword">const</span> reducersKeys = <span class="hljs-built_in">Object</span>.keys(reducers)
  <span class="hljs-keyword">return</span> (state = {}, action) =&gt; {
    <span class="hljs-keyword">return</span> reducersKeys.reduce((acc, key) =&gt; {
      acc[key] = reducers[key](state[key], action)
      <span class="hljs-keyword">return</span> acc
    }, {})
  }
}</code></pre>
<p>Maintenant, on peut bien séparer ses reducers :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { users } <span class="hljs-keyword">from</span> <span class="hljs-string">"./reducers/user"</span>
<span class="hljs-keyword">import</span> { tweets } <span class="hljs-keyword">from</span> <span class="hljs-string">"./reducers/tweets"</span>

<span class="hljs-keyword">const</span> reducer = combineReducers({
  users,
  tweets,
})

<span class="hljs-keyword">const</span> store = createStore(reducer)</code></pre>
<h2 id="4-permettre-lajout-de-middlewares"><a href="#4-permettre-lajout-de-middlewares" class="phenomic-HeadingAnchor">#</a>4. Permettre l&#x27;ajout de middlewares</h2>
<p>Les middlewares apportent toute la liberté de personalisation de Redux. L&#x27;un des plus populaires est le <a href="https://github.com/gaearon/redux-thunk"><em>thunk middleware</em></a>, qui permet de passer une fonction à la place d&#x27;une action, et de dispatcher depuis cette fonction, ce qui peut s&#x27;avérer très utile pour gérer des réponses asynchrones.</p>
<p>On va donc créer une fonction <code>applyMiddleware</code>, qui va enrichir un store en ajoutant une sorte de hook sur sa méthode dispatch.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// compose(a, b, c) équivaut à (...args) =&gt; a(b(c(...args)))</span>
<span class="hljs-keyword">const</span> compose = (...funcs) =&gt; {
  <span class="hljs-keyword">const</span> last = funcs[funcs.length - <span class="hljs-number">1</span>]
  <span class="hljs-keyword">const</span> rest = funcs.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))
}

<span class="hljs-keyword">const</span> applyMiddleware = (...middlewares) =&gt; {
  <span class="hljs-keyword">return</span> (store) =&gt; {
    <span class="hljs-comment">// cette API sera passée à chaque middleware, afin qu'il puisse récupérer</span>
    <span class="hljs-comment">// l'état en cours et dispatcher des actions</span>
    <span class="hljs-keyword">const</span> middlewareAPI = {
      getState: store.getState,
      dispatch: (action) =&gt; dispatch(action)
    }
    <span class="hljs-keyword">const</span> chain = middlewares.map((middleware) =&gt; middleware(middlewareAPI))
    <span class="hljs-keyword">let</span> dispatch = compose(...chain)(store.dispatch)
    <span class="hljs-keyword">return</span> {
      ...store,
      dispatch,
    }
  }
}</code></pre>
<blockquote>
<p>NOTE: l&#x27;API de Redux prend <code>createStore</code> plutôt que <code>store</code> en paramètre, la différence est volontaire dans cette démarche de simplification</p>
</blockquote>
<p>Voilà, maintenant on peut faire</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> thunk = ({ dispatch, getState }) =&gt; (next) =&gt; (action) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">return</span> action(dispatch, getState)
  }
  <span class="hljs-keyword">return</span> next(action)
}

<span class="hljs-keyword">const</span> store = applyMiddleware(thunk)(createStore(reducer))

<span class="hljs-comment">// et maintenant on peut faire</span>
store.dispatch((dispatch, getState) =&gt; {
  dispatch({ type: <span class="hljs-string">"FOO"</span> })
  setTimeout(() =&gt; {
    dispatch({ type: <span class="hljs-string">"BAR"</span> })
  })
})</code></pre>
<p>Voilà voilà, j&#x27;espère que cet article a pu vous éclairer un petit peu sur le fonctionnement de Redux et vous permettra de l&#x27;aborder avec plus de serénité.</p>
<p>Zoub&#x27;</p>
]]></description><link>http://putaindecode.io/fr/articles/js/redux/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/redux/</guid><pubDate>Thu, 09 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction à Flow, pour du code qui tourne du premier coup]]></title><description><![CDATA[<pre><code class="hljs language-javascript"><span class="hljs-built_in">document</span>.body.firstChild.getBoundingClientRect()</code></pre>
<p>Cette hypothétique ligne de code ne fonctionne pas tout le temps.</p>
<p>La raison c&#x27;est que <code>element.firstChild</code> est un <code>Node</code> et que tous les <code>Node</code> ne possèdent pas la méthode <code>getBoundingClientRect</code>, que l&#x27;on trouve systématiquement sur les <code>Element</code>, une classe héritant de <code>Node</code>.</p>
<p>Ce type d&#x27;erreur est assez commun, et malheureusement JavaScript n&#x27;en fout pas une pour nous prévenir que <em>attention là ça peut merder</em>. Le langage préfère nous prévenir au <em>runtime</em>, quand c&#x27;est déjà trop tard, parce que le bug s&#x27;est produit.</p>
<p>Et c&#x27;est parce que JavaScript est un langage … à typage <strong>faible</strong> et <strong>dynamique</strong>.</p>
<p>Faible, parce que si l&#x27;on effectue une opération entre deux valeurs ayant des types incompatibles, JavaScript va essayer de convertir les types de la manière qui lui semble la moins déconnante.</p>
<p>Exemple <em>feat. la conscience de JavaScript™</em></p>
<pre><code class="hljs language-javascript"><span class="hljs-string">"1"</span> + <span class="hljs-number">1</span>
<span class="hljs-comment">// bon alors, vu que la string peut être à peu près n'importe quoi,</span>
<span class="hljs-comment">// y'a un bon risque pour qu'une conversion en chiffre donne NaN,</span>
<span class="hljs-comment">// donc on va plutôt convertir le chiffre en string et faire une</span>
<span class="hljs-comment">// concaténation</span>
<span class="hljs-string">"11"</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-string">"1"</span> * <span class="hljs-number">1</span>
<span class="hljs-comment">// putain mais qui a écrit cette merde encore ?</span>
<span class="hljs-comment">// bon ben là si c'est une multiplication j'ai pas le choix,</span>
<span class="hljs-comment">// on va convertir la string en nombre</span>
<span class="hljs-number">1</span></code></pre>
<p>Dynamique, en opposition à statique, parce que les tests de type sont faits au runtime.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> toLowerCase = (value) =&gt; {
  <span class="hljs-keyword">return</span> value.toLowerCase()
}

toLowerCase(<span class="hljs-number">3</span>)
<span class="hljs-comment">// bon alors, (3).toLowerCase c'est undefined</span>
<span class="hljs-comment">// undefined c'est pas une fonction, ERREUR</span></code></pre>
<h2 id="comment-on-a-fait-jusque-là-"><a href="#comment-on-a-fait-jusque-l%C3%A0-" class="phenomic-HeadingAnchor">#</a>Comment on a fait jusque là ?</h2>
<h3 id="de-la-documentation"><a href="#de-la-documentation" class="phenomic-HeadingAnchor">#</a>De la documentation</h3>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */</span>
<span class="hljs-keyword">const</span> multiply = (a, b) =&gt; {
  <span class="hljs-keyword">return</span> a * b
}</code></pre>
<p>Ah bah c&#x27;est bien, maintenant toute l&#x27;équipe sait quels types sont attendus. Ça n&#x27;empêche pas les erreurs au runtime mais au moins on est au courant.</p>
<h3 id="aller-à-fond-dans-le-typage-dynamique"><a href="#aller-%C3%A0-fond-dans-le-typage-dynamique" class="phenomic-HeadingAnchor">#</a>Aller à fond dans le typage dynamique</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> multiply = (a, b) =&gt; {
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"number"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>()
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"number"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>()
  }
  <span class="hljs-keyword">return</span> a * b
}</code></pre>
<p>On peut vérifier les types au runtime pour détecter les bugs possibles de manière plus drastique en dev, on se retrouvera toujours avec un souci en production, qui fera péter le comportement attendu.</p>
<h3 id="faire-comme-si-cétait-pas-grave"><a href="#faire-comme-si-c%C3%A9tait-pas-grave" class="phenomic-HeadingAnchor">#</a>Faire comme si c&#x27;était pas grave</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> multiply = (a, b) =&gt; {
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"number"</span>) {
    a = <span class="hljs-number">0</span>
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"number"</span>) {
    b = <span class="hljs-number">0</span>
  }
  <span class="hljs-keyword">return</span> a * b
}</code></pre>
<p>On peut faire du &quot;defensive programming&quot;. Au lieu de laisser le bug arriver, on le tolère. Dans 99% des cas, le résultat ne sera absolument pas celui que l&#x27;on attend, et on ne prévient même pas de quand ça foire.</p>
<h2 id="comment-ça-se-passe-ailleurs-"><a href="#comment-%C3%A7a-se-passe-ailleurs-" class="phenomic-HeadingAnchor">#</a>Comment ça se passe ailleurs ?</h2>
<p>D&#x27;autres langages utilisent un typage statique, ce qui veut dire que le programme ne compilera pas si les types peuvent être incorrects.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">"1"</span>;;

<span class="hljs-keyword">value</span> + <span class="hljs-number">1</span>;;</code></pre>
<p>OCaml, quand vous essayez de faire tourner ce code va vous sortir un gros</p>
<pre><code>File &quot;test.ml&quot;, line 3, characters 0-5:
Error: This expression has type string but an expression was expected of type
         int
</code></pre>
<h2 id="et-comment-peut-on-avoir-ça-en-js-"><a href="#et-comment-peut-on-avoir-%C3%A7a-en-js-" class="phenomic-HeadingAnchor">#</a>Et comment peut-on avoir ça en JS ?</h2>
<p>C&#x27;est là que <a href="http://flowtype.org">Flow</a> intervient. C&#x27;est un outil d&#x27;analyse statique de JS. Il détecte les incompatibilités de types au sein du code.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">const</span> multiply = (a, b) =&gt; {
  <span class="hljs-keyword">return</span> a * b
}

multiply(<span class="hljs-number">1</span>, <span class="hljs-string">"1"</span>)</code></pre>
<pre><code>6: multiply(1, &quot;1&quot;)
   ^^^^^^^^^^^^^^^^ function call
3:   return a * b
                ^ string. This type is incompatible with
3:   return a * b
            ^^^^^ number
</code></pre>
<p>Dans le cas précédent, Flow analyse le code et comprend qu&#x27;une opération entre <code>string</code> et <code>number</code> comporte une incompatibilité.</p>
<p>Du coup, on peut avoir du code qui tourne du premier coup parce qu&#x27;il a éliminé toutes nos petites erreurs bêtes. En prime, ça permet d&#x27;arrêter de faire des tests unitaires bateau sur les types.</p>
<p>Flow ajoute par ailleurs une syntaxe pour définir les types attendus dans une situation donnée. On utilise <code>:</code> suivi du type attendu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-comment">// les types built-ins sont compris naturellement par flow</span>
<span class="hljs-keyword">const</span> foo: string = <span class="hljs-string">"foo"</span>
<span class="hljs-keyword">const</span> bar: number = <span class="hljs-number">3</span>
<span class="hljs-comment">// on peut typer les valeurs contenues dans un array</span>
<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Array</span>&lt;string&gt; = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>]
<span class="hljs-comment">// on peut typer des structures</span>
<span class="hljs-keyword">const</span> object: { foo: string, bar: number } = { foo, bar }
<span class="hljs-comment">// définir des valeurs litérales autorisées</span>
<span class="hljs-keyword">const</span> value: <span class="hljs-string">"enabled"</span> | <span class="hljs-string">"disabled"</span> = <span class="hljs-string">"enabled"</span>
<span class="hljs-comment">// des unions de types</span>
<span class="hljs-keyword">const</span> stringOrNumber: string | number = <span class="hljs-string">"foo"</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">array: Array&lt;number&gt;</span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> array.reduce((acc, item) =&gt; acc + item, <span class="hljs-number">0</span>)
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
  name: string;
  <span class="hljs-keyword">constructor</span>(name: string) { <span class="hljs-keyword">this</span>.name = name }
}
<span class="hljs-comment">// utiliser la relation prototypale pour typer une valeur</span>
<span class="hljs-keyword">const</span> person: Person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"foo"</span>)</code></pre>
<p>Flow permet également de créer des alias de types, ce qui est essentiel pour les partager au sein d&#x27;une codebase. Une syntaxe pour importer les types de fichier existe également. Ces imports sont supprimés du build final.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">import</span> type { MediaType } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MediaType"</span>

<span class="hljs-keyword">export</span> type UserType = {
  username: string,
  firstName?: string,
  lastName?: string,
  email: string,
  avatar: MediaType,
}</code></pre>
<p>Lorsque l&#x27;on écrit du code qui se fout du type, on peut utiliser les <em>generics</em>, qui est une sorte de placeholder de type.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-comment">// `T` est ici un type qui sera défini au call-site.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLast</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">
  array: Array&lt;T&gt;,
  func: (item: T, index: number, array: Array&lt;T&gt;</span>) =&gt; <span class="hljs-title">any</span>
): <span class="hljs-title">null</span> | <span class="hljs-title">T</span> </span>{
  <span class="hljs-keyword">let</span> index = array.length
  <span class="hljs-keyword">while</span>(--index &gt;= <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> item = array[index]
    <span class="hljs-keyword">if</span>(func(item, index, array)) {
      <span class="hljs-keyword">return</span> item
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}

<span class="hljs-comment">// Flow sait que dans ce cas `T` est un nombre</span>
<span class="hljs-keyword">const</span> lastEvenNumber: ?number = findLast(
  [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> ],
  (item) =&gt; item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>
)</code></pre>
<p>Flow permet également de typer par structure partielle attendue.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-comment">// l'inteface `named` permet de s'assurer que la valeur testée contient</span>
<span class="hljs-comment">// une méthode `getName` retournant une `string`</span>
interface named {
  getName(): string,
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
  name: string;
  <span class="hljs-keyword">constructor</span>(name: string) {
    <span class="hljs-keyword">this</span>.name = name
  }
  getName() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name
  }
}

<span class="hljs-keyword">const</span> person: named = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Luke Skywalker"</span>)</code></pre>
<p>React est supporté directement, et Flow peut remplacer les <code>propTypes</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> type { Element <span class="hljs-keyword">as</span> ReactElement } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> type { UserType } <span class="hljs-keyword">from</span> <span class="hljs-string">"../types/UserType"</span>

<span class="hljs-comment">// &lt;DefaultProps, Props, State&gt;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>&lt;<span class="hljs-title">void</span>, <span class="hljs-title">Props</span>, <span class="hljs-title">void</span>&gt; </span>{
  render(): ReactElement {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {user.username}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

type Props = {
  user: UserType,
}</code></pre>
<h2 id="mais-cest-pas-du-js-valide"><a href="#mais-cest-pas-du-js-valide" class="phenomic-HeadingAnchor">#</a>Mais c&#x27;est pas du JS valide</h2>
<p>Pas de panique, pour ça il existe des plugins babel:</p>
<pre><code class="hljs language-console">npm install --save-dev babel-plugin-syntax-flow babel-plugin-transform-flow-strip-types</code></pre>
<p>et vous n&#x27;avez plus qu&#x27;à ajouter <code>&quot;syntax-flow&quot;</code> et <code>&quot;transform-flow-strip-types&quot;</code> à votre <code>.babelrc</code>.</p>
<h2 id="mais-je-peux-pas-utiliser-babel-sur-mon-projet"><a href="#mais-je-peux-pas-utiliser-babel-sur-mon-projet" class="phenomic-HeadingAnchor">#</a>Mais je peux pas utiliser babel sur mon projet</h2>
<p>C&#x27;est ballot, mais tu peux quand même utiliser Flow avec de jolis commentaires.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">const</span> add = (a<span class="hljs-comment">/*: number */</span>, b<span class="hljs-comment">/*: number */</span>)<span class="hljs-comment">/*: number */</span> =&gt; {
  <span class="hljs-keyword">return</span> a + b
}

add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</code></pre>
<p>Allez, maintenant pas d&#x27;excuse pour ne pas typer son JS, donc ce serait pas mal d&#x27;aller sur <a href="http://flowtype.org/docs/getting-started.html#_">le site de Flow</a> pour en savoir un peu plus.</p>
<p>Bisous bisous.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/flow/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/flow/</guid><pubDate>Tue, 07 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction to Flow, to make your code run on the first try]]></title><description><![CDATA[<pre><code class="hljs language-javascript"><span class="hljs-built_in">document</span>.body.firstChild.getBoundingClientRect()</code></pre>
<p>This hypothetical line of code doesn&#x27;t always work.</p>
<p>The reason for this is that <code>element.firstChild</code> is a <code>Node</code>, not all of which have a <code>getBoundingClientRect</code> method, which is always found on <code>Elements</code>, a class that inherits from <code>Node</code>.</p>
<p>This kind of error is rather usual, and unfortunately JavaScript doesn&#x27;t quite get out of its way to warn us that <em>oi m8 that might not work</em>. JS actually prefers warning us at <em>runtime</em> when it&#x27;s too late because the bug already happened.</p>
<p>That is because JavaScript is a <strong>weakly/dynamically-typed</strong> language.</p>
<p>Weakly-typed, because if you try to make an operation with two values that have incompatible types, JS will convert those types to ones that it thinks will be the most adequate.</p>
<p>Example <em>feat. JavaScript&#x27;s Inner Voice™</em></p>
<pre><code class="hljs language-javascript"><span class="hljs-string">"1"</span> + <span class="hljs-number">1</span>
<span class="hljs-comment">// alright alright, so that string might contain absolutely anything</span>
<span class="hljs-comment">// if I tried to make it a number it could become NaN</span>
<span class="hljs-comment">// let's just make the number a string and concatenate both of them</span>
<span class="hljs-string">"11"</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-string">"1"</span> * <span class="hljs-number">1</span>
<span class="hljs-comment">// who the fuck wrote that crap?</span>
<span class="hljs-comment">// okay, that's a multiplication</span>
<span class="hljs-comment">// no choice but to make that string a number</span>
<span class="hljs-number">1</span></code></pre>
<p>Dynamically-typed, contrary to statically-typed, because type tests are made at runtime.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> toLowerCase = (value) =&gt; {
  <span class="hljs-keyword">return</span> value.toLowerCase()
}

toLowerCase(<span class="hljs-number">3</span>)
<span class="hljs-comment">// uhm. (3).toLowerCase is undefined</span>
<span class="hljs-comment">// undefined ain't a function, ERROR</span></code></pre>
<h2 id="how-did-we-do-so-far"><a href="#how-did-we-do-so-far" class="phenomic-HeadingAnchor">#</a>How did we do so far?</h2>
<h3 id="using-docs"><a href="#using-docs" class="phenomic-HeadingAnchor">#</a>Using docs</h3>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */</span>
<span class="hljs-keyword">const</span> multiply = (a, b) =&gt; {
  <span class="hljs-keyword">return</span> a * b
}</code></pre>
<p>Good, now the team knows what types the function needs. It doesn&#x27;t quite prevent runtime errors from happening but at least, hey, it&#x27;s something.</p>
<h3 id="going-all-the-way-in-dynamic-typing"><a href="#going-all-the-way-in-dynamic-typing" class="phenomic-HeadingAnchor">#</a>Going all the way in dynamic typing</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> multiply = (a, b) =&gt; {
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"number"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>()
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"number"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>()
  }
  <span class="hljs-keyword">return</span> a * b
}</code></pre>
<p>We can check types at runtime to find possible bugs in a drastic way, but that still doesn&#x27;t protect us from that one issue that will break our app.</p>
<h3 id="acting-like-its-no-biggie"><a href="#acting-like-its-no-biggie" class="phenomic-HeadingAnchor">#</a>Acting like it&#x27;s no biggie</h3>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> multiply = (a, b) =&gt; {
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"number"</span>) {
    a = <span class="hljs-number">0</span>
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"number"</span>) {
    b = <span class="hljs-number">0</span>
  }
  <span class="hljs-keyword">return</span> a * b
}</code></pre>
<p>That&#x27;s &quot;defensive programming&quot; for you. Instead of preventing the bug from happening, we tolerate it. In 99% of all cases, the result will definitely not be the one you expected and you won&#x27;t even know when something went wrong.</p>
<h2 id="how-are-other-languages-doing"><a href="#how-are-other-languages-doing" class="phenomic-HeadingAnchor">#</a>How are other languages doing?</h2>
<p>Other languages use static typing, which means the program won&#x27;t compile if the types are wrong.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">"1"</span>;;

<span class="hljs-keyword">value</span> + <span class="hljs-number">1</span>;;</code></pre>
<p>If you try to run the above code, OCaml will grace you with a nice</p>
<pre><code>File &quot;test.ml&quot;, line 3, characters 0-5:
Error: This expression has type string but an expression was expected of type
         int
</code></pre>
<h2 id="okay-how-do-we-get-this-in-js"><a href="#okay-how-do-we-get-this-in-js" class="phenomic-HeadingAnchor">#</a>Okay, how do we get this in JS?</h2>
<p>That&#x27;s the part where <a href="http://flowtype.org">Flow</a>, a static analysis tool for JS, does its magic; it detects typing incompatibilities in your code.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">const</span> add = (a, b) =&gt; {
  <span class="hljs-keyword">return</span> a + b
}

add(<span class="hljs-number">1</span>, <span class="hljs-string">"1"</span>)</code></pre>
<pre><code>6: multiply(1, &quot;1&quot;)
   ^^^^^^^^^^^^^^^^ function call
3:   return a * b
                ^ string. This type is incompatible with
3:   return a * b
            ^^^^^ number
</code></pre>
<p>In the previous case, Flow analyses your code and understands that an operation of a <code>string</code> and a <code>number</code> is not directly possible.
This means we can have code running on the first try every time, because Flow eliminates all our stupid little mistakes. As a bonus, it also avoids useless unit tests on types.</p>
<p>Flow also adds a syntax to define expected types in a given situation. We use <code>:</code> followed by the type the value should have.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-comment">// built-in types are naturally understood by flow</span>
<span class="hljs-keyword">const</span> foo: string = <span class="hljs-string">"foo"</span>
<span class="hljs-keyword">const</span> bar: number = <span class="hljs-number">3</span>
<span class="hljs-comment">// we can add typing to values within an array</span>
<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Array</span>&lt;string&gt; = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>]
<span class="hljs-comment">// we can add typing to structures</span>
<span class="hljs-keyword">const</span> object: { foo: string, bar: number } = { foo, bar }
<span class="hljs-comment">// or define allowed literal values</span>
<span class="hljs-keyword">const</span> value: <span class="hljs-string">"enabled"</span> | <span class="hljs-string">"disabled"</span> = <span class="hljs-string">"enabled"</span>
<span class="hljs-comment">// or type unions</span>
<span class="hljs-keyword">const</span> stringOrNumber: string | number = <span class="hljs-string">"foo"</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">array: Array&lt;number&gt;</span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> array.reduce((acc, item) =&gt; acc + item, <span class="hljs-number">0</span>)
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
  name: string;
  <span class="hljs-keyword">constructor</span>(name: string) { <span class="hljs-keyword">this</span>.name = name }
}
<span class="hljs-comment">// or even use prototypal relations to add typing to a specific value</span>
<span class="hljs-keyword">const</span> person: Person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"foo"</span>)</code></pre>
<p>Flow allows creation of typing aliases, which is essential to share them within a codebase. A syntax for importing types from a file also exists. Those imports are purged from the build.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">import</span> type { MediaType } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MediaType"</span>

<span class="hljs-keyword">export</span> type UserType = {
  username: string,
  firstName?: string,
  lastName?: string,
  email: string,
  avatar: MediaType,
}</code></pre>
<p>When you write code that doesn&#x27;t care about types, you can use <em>generics</em> which are kinda like type placeholders.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-comment">// `T here, is a type that will defined at the call-site</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLast</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">
  array: Array&lt;T&gt;,
  func: (item: T, index: number, array: Array&lt;T&gt;</span>) =&gt; <span class="hljs-title">any</span>
): <span class="hljs-title">null</span> | <span class="hljs-title">T</span> </span>{
  <span class="hljs-keyword">let</span> index = array.length
  <span class="hljs-keyword">while</span>(--index &gt;= <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> item = array[index]
    <span class="hljs-keyword">if</span>(func(item, index, array)) {
      <span class="hljs-keyword">return</span> item
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}

<span class="hljs-comment">// Flow knows that in this case, `T` will be a number</span>
<span class="hljs-keyword">const</span> lastEvenNumber: ?number = findLast(
  [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> ],
  (item) =&gt; item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>
)</code></pre>
<p>Flow also allows typing by expected partial structure.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-comment">// the interface allows to ensure that the tested value contains</span>
<span class="hljs-comment">// a `getName` method that returns a `string`</span>
interface named {
  getName(): string,
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
  name: string;
  <span class="hljs-keyword">constructor</span>(name: string) {
    <span class="hljs-keyword">this</span>.name = name
  }
  getName() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name
  }
}

<span class="hljs-keyword">const</span> person: named = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Luke Skywalker"</span>)</code></pre>
<p>React is supported out of the box, and Flow can be used to replace <code>propTypes</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> type { Element <span class="hljs-keyword">as</span> ReactElement } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> type { UserType } <span class="hljs-keyword">from</span> <span class="hljs-string">"../types/UserType"</span>

<span class="hljs-comment">// &lt;DefaultProps, Props, State&gt;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>&lt;<span class="hljs-title">void</span>, <span class="hljs-title">Props</span>, <span class="hljs-title">void</span>&gt; </span>{
  render(): ReactElement {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {user.username}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

type Props = {
  user: UserType,
}</code></pre>
<h2 id="but-that-isnt-valid-js"><a href="#but-that-isnt-valid-js" class="phenomic-HeadingAnchor">#</a>But that isn&#x27;t valid JS</h2>
<p>Don&#x27;t panic, there are babel plugins for that:</p>
<pre><code class="hljs language-console">npm install --save-dev babel-plugin-syntax-flow babel-plugin-transform-flow-strip-types</code></pre>
<p>and then you only have to add <code>&quot;syntax-flow&quot;</code> and <code>&quot;transform-flow-strip-types&quot;</code> to your <code>.babelrc</code>.</p>
<h2 id="what-if-i-cant-use-babel-on-my-project"><a href="#what-if-i-cant-use-babel-on-my-project" class="phenomic-HeadingAnchor">#</a>What if I can&#x27;t use babel on my project?</h2>
<p>Well first off, sorry for you. But you still can use Flow with nice comments.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/* @flow */</span>
<span class="hljs-keyword">const</span> add = (a<span class="hljs-comment">/*: number */</span>, b<span class="hljs-comment">/*: number */</span>)<span class="hljs-comment">/*: number */</span> =&gt; {
  <span class="hljs-keyword">return</span> a + b
}

add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</code></pre>
<p>Alright, now none of you have any excuses not to type your JS so it would be quite a good idea to go on <a href="http://flowtype.org/docs/getting-started.html#_">Flow&#x27;s website</a> to learn a little more about it.</p>
<p>Buh-bye.</p>
]]></description><link>http://putaindecode.io/en/articles/js/flow/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/flow/</guid><pubDate>Tue, 07 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Déploiement continu avec Travis-CI (et GitHub Pages)]]></title><description><![CDATA[<p>On va partir comme ça : on a un projet sur git et tous les commits dans la
branche <code>master</code> provoqueront une mise en production automatique une fois les
tests validés.</p>
<p>Les autres commits sur les autres branches et pull/merge requests joueront juste
les tests pour notifier l&#x27;état. Quand même.</p>
<h2 id="cest-qui-travis"><a href="#cest-qui-travis" class="phenomic-HeadingAnchor">#</a>C&#x27;est qui Travis?</h2>
<p><a href="https://travis-ci.com/">Travis-CI</a> est un service en ligne qui permet de tester
et déployer ses applications de manière automatisée.</p>
<p>Ce service payant propose une solution gratuite à tous les projets open source,
ce qui est assez cool. Cette version est disponible sur
<a href="https://travis-ci.org/">travis-ci.org</a>.
Il existe bien entendu plein d&#x27;autres services similaires, mais Travis-CI étant
très répandu dans la communauté open source, on le prendra pour notre exemple.</p>
<h2 id="configuration-de-travis-ci"><a href="#configuration-de-travis-ci" class="phenomic-HeadingAnchor">#</a>Configuration de Travis-CI</h2>
<p>Travis-CI fonctionne avec un fichier de configuration assez simple. Il n&#x27;y a
qu&#x27;à voir <a href="https://github.com/putaindecode/putaindecode.io/blob/master/.travis.yml">le
nôtre</a>.</p>
<p>Voici ci-dessous une version minimale pour faire tourner un projet node par
exemple :</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">language:</span> node_js</code></pre>
<p>Oui, c&#x27;est tout. Selon le language et/ou les fichiers présents,
Travis-CI va choisir la commande de test par défaut.
Avec node par exemple, ce sera <code>npm test</code> si un package.json est présent.
Si un <a href="/fr/articles/make/">Makefile</a> est de la partie, Travis-CI va exécuter
<code>make test</code>.</p>
<p>Voici un fichier plus complet avec quelques exemples et trucs bons à savoir.</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">language:</span> node_js

<span class="hljs-attr">node_js:</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">'5'</span>
<span class="hljs-bullet">  -</span> ‘<span class="hljs-number">4</span>’

<span class="hljs-comment"># échoue dès qu'une erreur intervient</span>
<span class="hljs-attr">matrix:</span>
<span class="hljs-attr">  fast_finish:</span> <span class="hljs-literal">true</span>

<span class="hljs-comment"># met en cache node_modules, à noter que dans ce genre d’utilisation pour des</span>
<span class="hljs-comment"># bibliothèques open source consommées via npm, il ne faudra pas oublier</span>
<span class="hljs-comment"># npm prune utilisé ci-après, histoire de ne pas lancer des tests avec</span>
<span class="hljs-comment"># des paquets encore en cache mais non présents dans le package.json</span>
<span class="hljs-attr">cache:</span>
<span class="hljs-attr">  directories:</span>
<span class="hljs-bullet">    -</span> node_modules

<span class="hljs-attr">before_install:</span>
<span class="hljs-bullet">  -</span> npm prune

<span class="hljs-comment"># ici on peut mettre des commandes à utiliser avec le script</span>
<span class="hljs-attr">before_script:</span>
  <span class="hljs-comment"># certains runners comme karma, testem ou testling peuvent avoir</span>
  <span class="hljs-comment"># besoin d'un écran pour fonctionner, voici l'astuce :)</span>
<span class="hljs-bullet">  -</span> export DISPLAY=:<span class="hljs-number">99.0</span>
<span class="hljs-bullet">  -</span> sh -e /etc/init.d/xvfb start

<span class="hljs-comment"># si on veut utiliser autre chose que la commande par défaut</span>
<span class="hljs-attr">script:</span> npm run test-with-coverage

<span class="hljs-comment"># voici un exemple de ce que l’on peut faire après les tests :</span>
<span class="hljs-comment"># on peut lancer une tâche qui va envoyer les informations de</span>
<span class="hljs-comment"># pourcentage de couverture de code à un service tiers.</span>
<span class="hljs-comment"># (eg: http://coveralls.io/, https://codecov.io/)</span>
<span class="hljs-attr">after_success:</span> <span class="hljs-string">'npm run coverage'</span>

<span class="hljs-comment"># partie intéressante : ici on ne va déployer que les commits sur la</span>
<span class="hljs-comment"># branche master uniquement pour une version de node</span>
<span class="hljs-comment"># (car sinon on déploierait plusieurs fois…)</span>
<span class="hljs-attr">deploy:</span>
<span class="hljs-attr">  skip_cleanup:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">  provider:</span> script
<span class="hljs-attr">  script:</span> ./scripts/deploy.sh
<span class="hljs-attr">  on:</span>
<span class="hljs-attr">    branch:</span> master
<span class="hljs-attr">    node:</span> <span class="hljs-string">'5'</span>

<span class="hljs-comment"># variables d'env</span>
<span class="hljs-attr">env:</span>
<span class="hljs-attr">  global:</span>
<span class="hljs-bullet">    -</span> NODE_ENV=production</code></pre>
<h2 id="exemple-concret"><a href="#exemple-concret" class="phenomic-HeadingAnchor">#</a>Exemple concret</h2>
<p>On va prendre un petit projet simple en JavaScript qu’on va déployer sur GitHub
Pages.
Il va donc nous falloir un token GitHub qu’on va encrypter via un utilitaire
spécifique afin de ne pas publier cela à la vue de tous.</p>
<h3 id="générer-un-token-github-encrypté-sur-travis-ci"><a href="#g%C3%A9n%C3%A9rer-un-token-github-encrypt%C3%A9-sur-travis-ci" class="phenomic-HeadingAnchor">#</a>Générer un token GitHub encrypté sur Travis-CI</h3>
<p>Le plus simple est d’utiliser l&#x27;interface GitHub pour <a href="https://github.com/settings/tokens/new">ajouter un
token</a>.</p>
<h4 id="encryption-du-token"><a href="#encryption-du-token" class="phenomic-HeadingAnchor">#</a>Encryption du token</h4>
<p>Maintenant, nous allons encrypter ce token. Vous avez 2 possibilités :</p>
<ul>
<li>soit installer le paquet node <code>travis-encrypt</code></li>
<li>soit installer la gem ruby <code>travis</code> (qui embarque la commande <code>encrypt</code>)</li>
</ul>
<h5 id="via-la-gem-ruby-travis"><a href="#via-la-gem-ruby-travis" class="phenomic-HeadingAnchor">#</a>Via la gem Ruby <code>travis</code></h5>
<pre><code class="hljs language-console">$ sudo gem install travis
$ travis encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>
<h5 id="via-le-paquet-node-travis-encrypt"><a href="#via-le-paquet-node-travis-encrypt" class="phenomic-HeadingAnchor">#</a>Via le paquet Node <code>travis-encrypt</code></h5>
<pre><code class="hljs language-bash">$ npm i -g travis-encrypt
$ travis-encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>
<p>Les 2 commandes devraient ajouter automatiquement le token encrypté dans votre
<code>.travis.yml</code> dans la section <code>env.global</code>.</p>
<pre><code class="hljs language-yml"><span class="hljs-comment"># …</span>

<span class="hljs-attr">env:</span>
<span class="hljs-attr">  global:</span>
<span class="hljs-bullet">    -</span> NODE_ENV=production
    <span class="hljs-comment"># Ajouter un petit commentaire pour indiquer que c’est votre token GitHub</span>
    <span class="hljs-comment"># GITHUB_TOKEN</span>
    <span class="hljs-comment"># cela permettra, si vous avez d’autres variables encryptées et</span>
    <span class="hljs-comment"># que vous devez changer de token pour X raison(s), de savoir lequel</span>
    <span class="hljs-comment"># supprimer</span>
<span class="hljs-attr">    - secure:</span> vqhHD....ROxGPQo= <span class="hljs-comment"># VOTRE TOKEN DOIT ETRE PAR LA</span>

    <span class="hljs-comment"># ici vous pouvez définir en plus d'autres variables non encryptées</span>
    <span class="hljs-comment"># qui seront réutilsables par la suite</span></code></pre>
<h3 id="utilisation-du-token-encrypté"><a href="#utilisation-du-token-encrypt%C3%A9" class="phenomic-HeadingAnchor">#</a>Utilisation du token encrypté</h3>
<h4 id="utilisation-dans-un-script"><a href="#utilisation-dans-un-script" class="phenomic-HeadingAnchor">#</a>Utilisation dans un script</h4>
<p>Imaginons que vous ayez un projet à deployer sur GitHub Pages (exemple : vous
générez un site statique avec <a href="https://phenomic.io/">Phenomic</a>, le générateur
de site statique qu&#x27;on utilise).
Vous allez devoir générer votre projet, puis ensuite pousser le dossier généré
sur votre branche <code>gh-pages</code>.</p>
<h4 id="utiliser-la-tâche-de-déploiement-seulement-si-nécessaire"><a href="#utiliser-la-t%C3%A2che-de-d%C3%A9ploiement-seulement-si-n%C3%A9cessaire" class="phenomic-HeadingAnchor">#</a>Utiliser la tâche de déploiement seulement si nécessaire</h4>
<p>Travis-CI possède une étape qui s&#x27;exécute après le succès des tests afin de
pouvoir faire un deploiement.</p>
<p><a href="https://docs.travis-ci.com/user/deployment/">https://docs.travis-ci.com/user/deployment/</a></p>
<p>Dans notre cas, on va choisir un provider très simple : un script bash.</p>
<p><strong>Par défaut, ceci sera executé pour tous les commits, sur toutes les
branches.</strong></p>
<p>On va donc devoir ajuster un peu le tir, car par exemple les commits sur
<code>gh-pages</code> ne doivent rien faire (déjà pour éviter la boucle infinie).
Il en sera de même pour les commits sur d&#x27;autres branches de travail ainsi que
les pull/merge requests, comme on l’a vu dans le précédent exemple.</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">deploy:</span>

  <span class="hljs-comment"># très important, on garde notre build, sans ça, nos fichiers buildés</span>
  <span class="hljs-comment"># sont supprimés.</span>
<span class="hljs-attr">  skip_cleanup:</span> <span class="hljs-literal">true</span>

<span class="hljs-attr">  provider:</span> script
<span class="hljs-attr">  script:</span> ./scripts/deploy.sh

  <span class="hljs-comment"># ici on pose notre restriction</span>
<span class="hljs-attr">  on:</span>
<span class="hljs-attr">    branch:</span> master
<span class="hljs-attr">    node:</span> <span class="hljs-string">'5'</span></code></pre>
<h4 id="Écrire-notre-fameux-scriptsdeploysh"><a href="#%C3%89crire-notre-fameux-scriptsdeploysh" class="phenomic-HeadingAnchor">#</a>Écrire notre fameux <code>scripts/deploy.sh</code></h4>
<p>Dans le cas d’un déploiement de dossier sur une branche <code>gh-pages</code>, on peut
faire de manière assez simple avec le script suivant :</p>
<pre><code class="hljs language-sh"><span class="hljs-meta">#!/usr/bin/env bash
</span>
<span class="hljs-comment"># on lit GIT_DEPLOY_REPO ou si y‘a pas on tente le package.json repository field</span>
<span class="hljs-comment"># (il faut une string et pas un objet dans ce cas)</span>
GIT_DEPLOY_REPO=${GIT_DEPLOY_REPO:-$(node <span class="hljs-_">-e</span>
<span class="hljs-string">'process.stdout.write(require("./package.json").repository)'</span>)}

<span class="hljs-comment"># on se déplace dans le dossier de build</span>
<span class="hljs-built_in">cd</span> dist &amp;&amp; \
<span class="hljs-comment"># on repart sur un repo git vierge, pas besoin de versionner quelque chose qui</span>
<span class="hljs-comment"># se build</span>
$(npm bin)/rimraf .git
git init &amp;&amp; \
<span class="hljs-comment"># il faut quelques infos pour que git soit content</span>
git config user.name <span class="hljs-string">"Travis CI"</span> &amp;&amp; \
git config user.email <span class="hljs-string">"github@travis-ci.org"</span> &amp;&amp; \
<span class="hljs-comment"># on met tout dans git et on commit</span>
git add . &amp;&amp; \
git commit -m <span class="hljs-string">"Deploy to GitHub Pages"</span> &amp;&amp; \
<span class="hljs-comment"># puis on force push sur gh-pages</span>
git push --force <span class="hljs-string">"<span class="hljs-variable">${GIT_DEPLOY_REPO}</span>"</span> master:gh-pages</code></pre>
<h2 id="ya-plus-quà-"><a href="#ya-plus-qu%C3%A0-" class="phenomic-HeadingAnchor">#</a>Y&#x27;a plus qu&#x27;à !</h2>
<p>Et voilà ! On pousse un commit sur <code>master</code> et la magie devrait opérer !</p>
<p><em>Note : pour commiter sans déclencher un build sur Travis-CI, il suffit d&#x27;ajouter
<code>[ci skip]</code> dans votre message de commit. Pratique quand on modifie juste un
README par exemple.</em></p>
<p>Cette méthode est celle que nous utilisons pour générer et deployer notre site
statique. Et cela permet, par exemple, si quelqu&#x27;un corrige une typo depuis
l&#x27;interface en ligne de GitHub, de n&#x27;avoir rien d&#x27;autre à faire que de « merger »
la correction
(et pour rappel : vous pouvez <strong>modifier</strong> n&#x27;importe quel article via le lien
situé plus bas).</p>
<p>Travis exécutera nos tests, génèrera notre site si les tests sont bons et mettra
ça en production. Les mises en prod&#x27; le vendredi à 19 h 45 ? Même pas peur.</p>
]]></description><link>http://putaindecode.io/fr/articles/ci/travis-ci/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/ci/travis-ci/</guid><pubDate>Tue, 19 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Angular 1.5 : un pas de plus vers les web-components]]></title><description><![CDATA[<p>Ce post a été écrit à la lumière du
<a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc1-quantum-fermentation-2016-01-15">changelog d&#x27;Angular 1.5.0 rc1</a>.<br>
Toutes information est succeptible d&#x27;évoluer au cours des publications de
nouvelles versions du framework.</p>
<h2 id="le-petit-nouveau--component"><a href="#le-petit-nouveau--component" class="phenomic-HeadingAnchor">#</a>Le petit nouveau : <code>.component()</code></h2>
<p>Avec l&#x27;arrivée imminente de la version 2, Angular commence lentement à préparer la
transition et apporte de nombreux changements à la v1 pour tenter de
combler l&#x27;écart entre les deux et rendre les changements moins pénibles.</p>
<p>On voit donc progressivement apparaitre de nouvelles fonctionnalités comme :</p>
<ul>
<li><del>un <a href="https://angular.github.io/router/">nouveau router</a> ?</del> </li>
<li>la possibilité d&#x27;<a href="https://docs.angularjs.org/api/ngResource/service/$resource#cancelling-requests">annuler une resource</a></li>
<li>les transclusions multiples</li>
<li>la compilation paresseuse des transclusions</li>
</ul>
<p>Mais le point qui nous intéresse particulièrement ici n&#x27;est autre que
le nouveau <em>helper</em> permettant la déclaration de similis
<a href="https://fr.wikipedia.org/wiki/Composants_web">composants web</a>, aka web-components.</p>
<p>Les habitués connaissaient déjà <a href="https://docs.angularjs.org/api/ng/service/$compile"><code>angular.directive()</code></a>,
un <em>helper</em> permettant la déclaration de composants réutilisables.
<code>angular.directive()</code> s&#x27;est donc enrichi au cours des années en faisant un atout
incontournable du framework de par sa flexibilité et sa simplicité.</p>
<p>Mais toutes ces possibilités de déclaration n&#x27;étaient plus vraiment en phase avec
les spécifications du W3C, <code>angular.component()</code> se présente donc un retour aux sources.</p>
<h2 id="de-directive-à-component"><a href="#de-directive-%C3%A0-component" class="phenomic-HeadingAnchor">#</a>De <code>.directive()</code> à <code>.component()</code></h2>
<p>Pour comprendre à quoi on arrive, il faut savoir de quoi on est parti.
De toute évidence vous ne pourrez pas transformer toutes vos vieilles directives
en composants web, du moins, pas sans compromis.</p>
<p>Pour rappel une directive Angular est définie par un objet JavaScript pouvant comporter
les attributs suivants :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> directiveObj = {
  template          : <span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>,
  transclude        : <span class="hljs-literal">false</span>,
  restrict          : <span class="hljs-string">'EA'</span>,
  scope             : <span class="hljs-literal">false</span>,
  bindToController  : <span class="hljs-literal">false</span>,
  controller        : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ },
  controllerAs      : <span class="hljs-string">'stringIdentifier'</span>,
}</code></pre>
<h3 id="restriction-à-la-forme-élémentaire"><a href="#restriction-%C3%A0-la-forme-%C3%A9l%C3%A9mentaire" class="phenomic-HeadingAnchor">#</a>Restriction à la forme élémentaire</h3>
<p>Ceux qui utilisent les directives Angular de manière régulière ne sont pas sans savoir
qu&#x27;il est possible de les instancier de 4 manières différentes dans son HTML en
modifiant l&#x27;attribut <code>restrict</code> :</p>
<ul>
<li>comme un élément avec <code>restrict : &#x27;E&#x27;</code></li>
<li>comme un attribut avec <code>restrict : &#x27;A&#x27;</code></li>
<li>comme une classe avec <code>restrict : &#x27;C&#x27;</code> (déconseillé)</li>
<li>comme un commentaire avec <code>restrict : &#x27;M&#x27;</code> (fortement déconseillé)</li>
</ul>
<p>On peut aussi autoriser l&#x27;utilisation mixe en combinant les lettres : <code>restrict : &#x27;EAC&#x27;</code></p>
<p><code>restrict</code> n&#x27;est donc plus configurable et est restreint <em>(sans mauvais jeu de mot)</em>
à la forme <code>&#x27;E&#x27;</code> en faisant un composant de façon claire.</p>
<h3 id="isolement-du-scope"><a href="#isolement-du-scope" class="phenomic-HeadingAnchor">#</a>Isolement du scope</h3>
<p>Contrairement à <code>.directive()</code>, <code>.component()</code> force l&#x27;isolement du scope,
ainsi on colle à la specification : le composant web est agnostique du contexte.</p>
<p>l&#x27;attribut <code>scope</code> est donc forcé à <code>{}</code> et n&#x27;est plus configurable.</p>
<h3 id="passage-de-paramètres-via-bindings"><a href="#passage-de-param%C3%A8tres-via-bindings" class="phenomic-HeadingAnchor">#</a>Passage de paramètres via <code>bindings</code></h3>
<p>La propriété <code>scope</code> n&#x27;étant plus disponible <code>component</code>. Il faut à présent utiliser la propriété <code>bindings</code>. La syntaxe de celle-ci est équivalent à celle de la propriété <code>scope</code>. Mais les éléments passés sont automatiquement attachés à l&#x27;instance du contrôleur lié au <code>component</code>.</p>
<p>Notons, que s&#x27;il reste possible d&#x27;utiliser la syntaxe <code>=</code> (two-way data binding), celle-ci est déconseillée au profit de la syntaxe <code>&lt;</code> (one-way data binding).</p>
<h3 id="utilisation-forcée-de-controlleras"><a href="#utilisation-forc%C3%A9e-de-controlleras" class="phenomic-HeadingAnchor">#</a>Utilisation <em>forcée</em> de <code>controllerAs</code></h3>
<p>Déjà présenté comme une <em><a href="https://toddmotto.com/digging-into-angulars-controller-as-syntax/">best practice</a></em>,
<code>controllerAs</code> fait son chemin de manière évidente jusqu&#x27;au nouveau <em>helper</em>
<code>.component()</code> son utilisation va de pair avec celle de <code>bindings</code>.</p>
<p>L&#x27;attribut, qui prend une chaine de caractères pour valeur, est à présent facultatif.
S&#x27;il est omit le controller est automatiquement aliassé par l&#x27;objet <code>$ctrl</code>.</p>
<h2 id="exemple-de-migration"><a href="#exemple-de-migration" class="phenomic-HeadingAnchor">#</a>Exemple de migration</h2>
<p>Prenons l&#x27;exemple d&#x27;une directive simple et transformons la en composant Angular pour
mettre en évidence l&#x27;ensemble des changements :</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">hello-world</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"World"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello-world</span>&gt;</span></code></pre>
<p>La syntaxe <em>directive</em> :</p>
<pre><code class="hljs language-js">angular.directive(<span class="hljs-string">'helloWorld'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorld</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    restrict          : <span class="hljs-string">'E'</span>,
    scope             : {},
    bindToController  : {
      name : <span class="hljs-string">'@'</span>
    },
    controller        : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorldCtrl</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.logName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
      }
    },
    controllerAs      : <span class="hljs-string">'hw'</span>,
    template          : <span class="hljs-string">'&lt;div&gt;&lt;span ng-click="hw.logName()"&gt;Hello {{hw.name}}!&lt;/span&gt;&lt;/div&gt;'</span>
  }
});</code></pre>
<p>La syntaxe <em>component</em> :</p>
<pre><code class="hljs language-js">angular.component(<span class="hljs-string">'helloWorld'</span>, {
  bindings: {
    name: <span class="hljs-string">'@'</span>
  },
  controller : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorldCtrl</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.logName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
  },
  template : <span class="hljs-string">'&lt;div&gt;&lt;span ng-click="$ctrl.logName()"&gt;Hi {{$ctrl.name}}!&lt;/span&gt;&lt;/div&gt;'</span>
});</code></pre>
<p>Les changements sont légers mais permettent une lecture améliorée des attributs.
Le composant est donc une version simplifiée de la directive, plus en phase avec
la logique d&#x27;Angular 2.</p>
<p>Ce nouveau <em>helper</em> permet donc l&#x27;introduction progressive des <em>web-components</em> au
sein d&#x27;Angular en vue de leur intégration et utilisation active dans la version 2.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/angular/components/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/angular/components/</guid><pubDate>Tue, 12 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Hello Swift]]></title><description><![CDATA[<blockquote>
<p>Le <strong>Swift</strong> est un langage de programmation présenté en <strong>2014</strong> par
<strong>Apple</strong>. Il a été créé pour simplifier le développement d&#x27;applications pour
les environnements d&#x27;Apple (iOS, OS X, tvOS, watchOS), car les nouveaux
développeurs,  non habitués à <code>Objective C</code>, trouvent souvent celui-ci  trop dur
à appréhender. En 2015, Apple présente <strong>Swift 2.0</strong>, une version finalisée et
stable du langage. <strong>Swift</strong> est <strong>open-source</strong> depuis novembre 2015.</p>
</blockquote>
<h2 id="le-playground"><a href="#le-playground" class="phenomic-HeadingAnchor">#</a>Le playground</h2>
<p>Avec Swift, Apple a introduit un nouveau moyen de s&#x27;amuser avec du code : le
<strong>playground</strong>. C&#x27;est à mi-chemin entre le script <code>python</code> et le <code>main de C</code>.
Vous pouvez y écrire des <code>fonctions</code>, y définir des <code>classes</code>, mais aussi y
exécuter du code en direct. Tout ceci est vraiment pratique pour <strong>tester des
algorithmes</strong>, des animations ou plus simplement <strong>apprendre à maitriser le
langage</strong>. Les <code>playgrounds</code> servent à prototyper plus qu’à écrire de vrais
outils.</p>
<p>Grâce à un partenariat entre Apple et IBM,  vous pouvez faire du <strong>Swift sur
votre navigateur</strong> avec Bluemix. La plate-forme de cloud coding d&#x27;IBM
<a href="https://swiftlang.ng.bluemix.net">swiftlang.ng.bluemix.net</a> offre ainsi un
<strong><code>playground</code> en ligne</strong> pour apprendre et vous entrainer en <strong>Swift</strong>. Donc
plus de limitation due à l&#x27;OS pour apprendre !</p>
<p>Sur OS X vous pouvez utiliser les <code>playground</code> avec Xcode, l&#x27;IDE d&#x27;Apple. Pour
créer un  <strong><code>playground</code></strong>,  vous ouvrez Xcode et <code>File→New→Playground</code>(ou
<kbd>⌥</kbd> + <kbd>⇧</kbd> + <kbd>⌘</kbd> + <kbd>N</kbd>). Vous nommez votre
<code>playground</code> et choisissez une plate-forme pour utiliser des frameworks
spécifiques pour chaque environnement (iOS ou OS X).</p>
<p><img src="./playground.jpg" alt="Playground"></p>
<p>Enfin, Swift peut être utilisé comme langage de script, en créant un fichier
<code>.swift</code>, à exécuter dans le terminal avec <code>swift [file].swift</code>. Cette méthode
offre peu de confort, car même en ouvrant le fichier sur Xcode vous n&#x27;aurez pas
l&#x27;autocomplétion. Mais si vous êtes un mordu de <strong>Linux</strong>, sachez qu&#x27;il existe
un compilateur Swift Linux fourni par Apple sur la <a href="https://swift.org/download/#linux">page dédiée sur
swift.org</a>.</p>
<h2 id="les-variables"><a href="#les-variables" class="phenomic-HeadingAnchor">#</a>Les variables</h2>
<p>Les variables peuvent être constantes ou non. Le précompilateur d&#x27;Xcode est
assez strict avec la notion de constante. Si vous déclarez une variable non
constante mais que vous ne la modifiez nulle part, il vous proposera toujours de
la passer en constante.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Exemple de variables/constantes</span>
<span class="hljs-keyword">var</span> aVariable:<span class="hljs-type">Type</span> = something <span class="hljs-comment">// variable (mutable)</span>
<span class="hljs-keyword">let</span> aConstant:<span class="hljs-type">Type</span> = somethingElse <span class="hljs-comment">// constante</span></code></pre>
<p>Swift est un langage typé, mais le type peut être implicite lors de la
déclaration. Swift typera alors la variable automatiquement.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> explicitString:<span class="hljs-type">String</span> = <span class="hljs-string">"Mario"</span>
<span class="hljs-keyword">let</span> implicitString = <span class="hljs-string">"Luigi"</span> <span class="hljs-comment">// This is a string too</span></code></pre>
<p>Par défaut, les variables ne peuvent pas être nulles. Pour qu&#x27;une variable soit
dite <em>optionelle</em>, il faut déclarer une variable explicite en ajoutant un <code>?</code> à
son type.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Ce code ne compile pas :</span>
<span class="hljs-keyword">var</span> implicitString = <span class="hljs-string">"Luigi"</span>
name = <span class="hljs-literal">nil</span> <span class="hljs-comment">// Error : Nil cannot be assigned to type 'String'</span>

<span class="hljs-comment">// Mais celui-ci, si</span>
<span class="hljs-keyword">let</span> explicitOptionalString:<span class="hljs-type">String</span>? = <span class="hljs-string">"Mario"</span>
explicitOptionalString = <span class="hljs-literal">nil</span> <span class="hljs-comment">// Olé 💃</span></code></pre>
<h2 id="affichage"><a href="#affichage" class="phenomic-HeadingAnchor">#</a>Affichage</h2>
<p>La fonction <code>print()</code> sert à afficher une chaîne de caractères dans la console
pour un script ou une application. Pour afficher des variables dans des chaînes
de caractères, on utilise cette syntaxe <code>\(maVariable)</code>. Exemple :</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> age:<span class="hljs-type">Int</span> = <span class="hljs-number">32</span>
<span class="hljs-keyword">let</span> name:<span class="hljs-type">String</span> = <span class="hljs-string">"Luigi"</span>
<span class="hljs-keyword">let</span> point:<span class="hljs-type">Float</span> = <span class="hljs-number">43.4</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> have <span class="hljs-subst">\(age)</span> and <span class="hljs-subst">\(point)</span> points"</span>)

<span class="hljs-comment">// Ou</span>
<span class="hljs-keyword">let</span> toPrint:<span class="hljs-type">String</span> = <span class="hljs-string">"<span class="hljs-subst">\(name)</span> have <span class="hljs-subst">\(age)</span> and <span class="hljs-subst">\(point)</span> points"</span>
<span class="hljs-built_in">print</span>(toPrint)</code></pre>
<h2 id="conditions--boucles"><a href="#conditions--boucles" class="phenomic-HeadingAnchor">#</a>Conditions &amp; boucles</h2>
<p>Un langage sans condition ça sert pas à grand-chose, donc voici la syntaxe :</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">if</span> (a &gt; x) || (a &lt; y) { <span class="hljs-comment">// Si a est plus grand que x ou plus petit que y</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a &gt; x OR a &lt; y "</span>) <span class="hljs-comment">// j'affiche</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; z { <span class="hljs-comment">// Sinon si ...</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a &lt; z"</span>)
} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Sinon</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"y &lt;= a &lt;= x"</span>)
}</code></pre>
<p>Quelques exemples de boucles <code>while</code> et <code>for</code> :</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// While</span>
<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">10</span> { <span class="hljs-comment">// Tant que i &lt; 10 j'affiche</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"i = <span class="hljs-subst">\(i)</span>"</span>)
    i+=<span class="hljs-number">1</span> <span class="hljs-comment">// incrémente i de 1</span>
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>...<span class="hljs-number">10</span>) { <span class="hljs-comment">// pour i de 0 à 10</span>
	<span class="hljs-built_in">print</span>(i)
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>...<span class="hljs-number">10</span>).<span class="hljs-built_in">reverse</span>() { <span class="hljs-comment">// pour i de 1 à 10 en moonwalk</span>
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.<span class="hljs-built_in">stride</span>(to: <span class="hljs-number">10</span>, by: <span class="hljs-number">2</span>) { <span class="hljs-comment">// pour i de 0 à 10 par saut de 2 (10 non compris)</span>
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-comment">// autre notation de For utilisant des Ranges</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">3</span>{
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-comment">// For-In : Pour mes éléments d'un Array</span>
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> myCollection {
    element.doSomething()
}

<span class="hljs-comment">// For-In : en enumurant la boucle</span>
<span class="hljs-keyword">for</span> (index,valeur) <span class="hljs-keyword">in</span> myCollection.<span class="hljs-built_in">enumerate</span>(){
	<span class="hljs-built_in">print</span>(<span class="hljs-string">"valeur à l'index [<span class="hljs-subst">\(index)</span>] -&gt; <span class="hljs-subst">\(valeur)</span>"</span>)
}</code></pre>
<blockquote>
<p>Depuis Swift 2.2, les notations <code>--</code> et <code>++</code> sont dépréciées, donc plus de i++ dans les boucles 😩. Ce qui explique aussi que les boucles For C-Style sont aussi dépréciées. Ex:<code>for var i = 0; i &lt; 3; i++</code>. Pour ce genre de boucle il faut utiliser la notation <code>(0...3)</code>.</p>
</blockquote>
<h2 id="fonctions"><a href="#fonctions" class="phenomic-HeadingAnchor">#</a>Fonctions</h2>
<p>Un script sans fonction c&#x27;est comme une raclette sans Saint-Nectaire. Beaucoup
de débutants le font mais une fois qu&#x27;on y a gouté, il est impossible s&#x27;en
passer !</p>
<p>Donc voici la syntaxe <del>d&#x27;un Saint-Nectaire</del>... d&#x27;une fonction :</p>
<pre><code class="hljs language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunctionName</span><span class="hljs-params">(myStringInput:String,myIntInput:Int)</span></span>-&gt;<span class="hljs-type">Int</span>{

    <span class="hljs-comment">// Votre code</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> <span class="hljs-comment">// Retour</span>
}</code></pre>
<p>En réalité, les fonctions sont un cas particulier d&#x27;utilisation d&#x27;une notion
introduite par Swift qu&#x27;ils appellent les <em>closures</em>. Pour les amateurs de
<em>Block</em> (Objective C, C++14) et  <strong>Lambdas</strong> (C++, Java,...), les closures
seront détaillées dans un prochain article.</p>
<h2 id="le-mot-de-la-fin"><a href="#le-mot-de-la-fin" class="phenomic-HeadingAnchor">#</a>Le mot de la fin</h2>
<p>Avec tout ça vous devriez déjà vous amuser un peu !
Pour information, les scripts Swift peuvent <strong>utiliser <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/">Foundation</a></strong>
sur Linux ou OS X , le framework de base des OS d&#x27;Apple bien connu des
développeurs OS X/iOS. Il permet le traitement des fichiers, des <code>String</code> et
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/">bien plus</a>.</p>
]]></description><link>http://putaindecode.io/fr/articles/swift/hello/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/swift/hello/</guid><pubDate>Tue, 01 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Vers les CSS modules]]></title><description><![CDATA[<blockquote>
<p>Je crois que même avant que je sache exactement ce qu&#x27;était le CSS, j&#x27;avais
déjà entendu quelqu&#x27;un me dire &quot;Je HAIS le CSS&quot;. Cette phrase était souvent dite
par un de mes amis du back-end, et souvent pour de très bonnes raisons. Cet
article n&#x27;essaiera pas de défendre ni de vous faire aimer le CSS, mais comme les
outils de développement front-end évoluent rapidement, je trouve intéressant
d&#x27;expliquer les nouvelles façons d&#x27;écrire le CSS.</p>
</blockquote>
<h2 id="retour-aux-bases"><a href="#retour-aux-bases" class="phenomic-HeadingAnchor">#</a>Retour aux bases</h2>
<p>D&#x27;abord, pour comprendre quel sont les problèmes que les nouveaux outils tentent
de résoudre, un petit rappel sur ce qu&#x27;est le CSS : <em>Cascading Style Sheets</em> ou
<em>Feuilles de style en cascade</em>.</p>
<p>Une feuille de style ? C&#x27;est facile ! C&#x27;est un bout de code qui lie des &quot;styles&quot;
à du HTML.
En cascade ? Et bien, quelques fois un élément HTML peut correspondre à
plusieurs styles, et &quot;en cascade&quot; est le groupe de règles qui permet de
déterminer lequel appliquer.</p>
<p>Voici du code CSS basique : nous voulons que nos titres h1 soient rouges.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>Ici, nous lions la <strong><em>règle (ou déclaration)</em></strong> <code>color: red</code> au <strong><em>sélecteur</em></strong>
&quot;h1&quot;. Un sélecteur peut contenir plusieurs règles dans son bloc de déclarations.</p>
<blockquote>
<p>Et les dernières lueurs de bonheur s&#x27;éteignent alors que nous entrons dans
l&#x27;enfer de la cascade</p>
</blockquote>
<h2 id="le-truc-qui-cascade"><a href="#le-truc-qui-cascade" class="phenomic-HeadingAnchor">#</a>Le truc qui cascade</h2>
<p>La cascade est pour moi un désastre qui rend le CSS très compliqué à maintenir
si on ne suit pas de lignes directrices ou on n&#x27;utilise pas d&#x27;outils pour
l&#x27;écrire. Je vais vous montrer quelques exemples simples pour vous expliquer les
principaux concepts de la cascade, mais gardez en tête que la plupart des
applications web contiennent de nos jours beaucoup de code, aggravant les effets
de la cascade.</p>
<p>La nécessité d&#x27;avoir un système comme la cascade vient du fait que le CSS permet
à plusieurs règles de style de s&#x27;appliquer à un même élément, ces dernières
pouvant même venir de plusieurs origines (du site, mais aussi du navigateur ou
encore même de l&#x27;utilisateur). Il faut donc pouvoir définir dans ce cas-là
quelle est la règle qui au final sera appliquée. Pour cela, la cascade donne à
chacune un poids, calculé selon un certain nombre de critères, et applique la
règle la plus lourde. Cela peut paraitre simple au premier abord, mais les
critères de calcul de poids ne le sont pas du tout.</p>
<p>Les règles qui sont les plus légères dans la cascade ne sont pas vraiment un
problème, mais il faut les connaitre afin de s&#x27;éviter des surprises :</p>
<h3 id="les-valeurs-par-défaut-du-navigateur"><a href="#les-valeurs-par-d%C3%A9faut-du-navigateur" class="phenomic-HeadingAnchor">#</a>Les valeurs par défaut du navigateur</h3>
<p>Voici le haut de la cascade. Ce sont les règles qui font qu&#x27;un titre h1 est gros
même si on ne l&#x27;a pas spécifié.</p>
<h3 id="lhéritage-des-parents"><a href="#lh%C3%A9ritage-des-parents" class="phenomic-HeadingAnchor">#</a>L&#x27;héritage des parents</h3>
<p>Ensuite, les règles sont héritées depuis les éléments HTML parents. Si on
reprend notre élément h1, si une règle <code>color: blue</code> est définie sur l&#x27;élément
<code>body</code>, le titre va en hériter, et sera donc bleu.</p>
<p>Ceci étant dit, on entre maintenant dans un niveau plus douloureux de la
cascade.</p>
<h3 id="lordre-des-règles"><a href="#lordre-des-r%C3%A8gles" class="phenomic-HeadingAnchor">#</a>L&#x27;ordre des règles</h3>
<p>La position d&#x27;une règle par rapport aux autres va influer sur son poids.
Deux règles auraient pu avoir le même poids si elles étaient à la même position
mais, au final, c&#x27;est la dernière qui sera la plus lourde et sera donc
appliquée.
<strong><em>La dernière.</em></strong>
Quand il s&#x27;agit de code assez simple, cela peut être facilement
compréhensible :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Facile, n&#x27;est-ce pas ? Le titre sera bleu ! Mais s&#x27;il y a une règle <code>color: red</code> dans un fichier CSS nommé <em>foo.css</em>, et une règle <code>color: blue</code> dans un
autre fichier nommé <em>bar.css</em>, que le fichier <em>foo.css</em> met plus de temps que le
fichier <em>bar.css</em> à charger, mais que le tag HTML référençant <em>foo.css</em> est
avant celui de <em>bar.css</em>, quelle règle est appliquée ? Eh bien, c&#x27;est plus
compliqué à savoir. <em>(indice : le temps de chargement n&#x27;est pas pris en compte)</em></p>
<h3 id="la-spécificité-des-sélecteurs"><a href="#la-sp%C3%A9cificit%C3%A9-des-s%C3%A9lecteurs" class="phenomic-HeadingAnchor">#</a>La spécificité des sélecteurs</h3>
<p>Ce critère est un niveau de complexité au-dessus des autres, <a href="https://specificity.keegan.st">si bien que des
personnes en ont fait des calculettes pour le
simplifier</a>. Je ne vais pas rentrer dans les
détails, mais il faut savoir que le poids d&#x27;un sélecteur est égal à la somme des
poids de tous les sélecteurs le composant.
Et que tous les sélecteurs n&#x27;ont pas le même poids.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.title</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Ici, le premier sélecteur pèse 10 parce qu&#x27;il contient un sélecteur de classe
CSS, qui pèse lui-même 10. Le deuxième sélecteur quant à lui pèse 3, parce qu&#x27;il
contient trois sélecteurs de tag, pesant chacun 1. Et donc, comme 10 &gt; 3, le
titre h1 sera rouge !</p>
<h3 id="les-styles-inline"><a href="#les-styles-inline" class="phenomic-HeadingAnchor">#</a>Les styles inline</h3>
<p>Les règles qui sont dans l&#x27;attribut “style” d&#x27;un élément HTML sont plus lourdes
que n&#x27;importe quel sélecteur défini précédemment. Et donc voici un titre bleu :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<h3 id="importance"><a href="#importance" class="phenomic-HeadingAnchor">#</a>Importance</h3>
<p>Et enfin le dernier critère, le God Mode, le broyeur de styles, le mot-clé
<strong><em>!important.</em></strong> Quand on veut VRAIMENT que le titre soit rouge :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>Et comme toute la cascade est à propos de poids, si deux règles sont marquées
comme !important, le reste des critères est toujours pris en compte pour
calculer laquelle est la plus lourde, et donc appliquée.</p>
<p><strong>…Et on ne peut pas faire plus compliqué que ça.</strong> Maintenant, imaginez des
milliers et des milliers de sélecteurs et règles cascadant les uns sur les
autres pour définir le style d&#x27;un site, et vous comprendrez l&#x27;enfer que peut
être le CSS. Ainsi, des développeurs CSS ont imaginé différentes méthodologies
et outils pour éviter ce cauchemar !</p>
<h2 id="lévolution-des-outils"><a href="#l%C3%A9volution-des-outils" class="phenomic-HeadingAnchor">#</a>L&#x27;évolution des outils</h2>
<p>Maintenant, je vais vous présenter comment ma façon d&#x27;écrire du CSS a évolué au
fil du temps. Ne vous attendez pas à une chronologie complète de tous les
outils inventés depuis la création du CSS en 1996 (j&#x27;avais 6 ans !) mais plutôt
une explication de comment je me suis débrouillé avec la cascade dans ma courte
expérience personnelle.</p>
<h3 id="pré-processeurs"><a href="#pr%C3%A9-processeurs" class="phenomic-HeadingAnchor">#</a>Pré-processeurs</h3>
<p>J&#x27;ai commencé à developper des applications web en 2012, en plein âge d&#x27;or <a href="/fr/articles/css/preprocesseurs/">des
pré-processeurs</a>. Ils
étaient apparus quelques années auparavant, comme le CSS lui-même n&#x27;était pas
suffisamment adapté pour construire des sites complexes. Les pré-processeurs
sont des compilateurs qui génèrent du code CSS à partir de languages légèrement
différents, comme <a href="http://sass-lang.com">Sass</a> ou <a href="http://lesscss.org">LESS</a>.
Ces nouveaux languages permettent de créer des variables par exemple, ou
d&#x27;imbriquer des sélecteurs, entre autres merveilleuses nouvelles
fonctionnalités.</p>
<p>On peut transformer ce vieux code CSS compliqué à maintenir :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#E5E5E5</span>;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<p>en cette bien <em>meilleure</em> version :</p>
<pre><code class="hljs language-scss"><span class="hljs-variable">$textColor</span>: <span class="hljs-number">#333333</span>;

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: lighten(<span class="hljs-variable">$textColor</span>, <span class="hljs-number">90%</span>);

  <span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>
  }
}</code></pre>
<p>Avec ces nouveaux outils, et pour éviter aux règles d&#x27;entrer en collision dans
la cascade, nous avons commencé à imbriquer nos sélecteurs et à répliquer toute
notre structure HTML dans le code de notre pré-processeur favori. Notre CSS se
retrouva donc avec des sélecteurs très long et lourds qui étaient associés
uniquement avec un element HTML précis, comme ce dernier :</p>
<blockquote>
<p>.searchPage .sideBar .refinements.default .category .star input</p>
</blockquote>
<p>Et ça a plutôt bien marché au début ! Mais ces sélecteurs n&#x27;étaient pas les plus
performants, et la structure du HTML étant répliquée, n&#x27;importe quel changement
dans cette dernière doit être répercuté dans les styles. Donc je suis passé à
autre chose.</p>
<h3 id="méthodologies-css"><a href="#m%C3%A9thodologies-css" class="phenomic-HeadingAnchor">#</a>Méthodologies CSS</h3>
<p>À ce moment, quelques nouvelles guidelines CSS ont commencé a attirer mon
attention. On pouvait les utiliser avec les pré-processeurs, et avaient pour but
d&#x27;éviter les collisions dans la cascade (tout comme l&#x27;imbrication des
sélecteurs) avec un certain nombre de règles, comme sur le nommage des
sélecteurs.</p>
<p>Ces méthodologies sont arrivées au moment ou je commençais à découper mes
développements en composants. L&#x27;imbrication des sélecteurs ne marchait pas très
bien avec ces derniers, vu que le but est de créer des bouts de code
réutilisables partout dans la web app, comme un bouton par exemple. La
méthodologie que j&#x27;utilise (toujours aujourd&#x27;hui) est appelée <a href="/fr/articles/css/bem/">BEM, pour Block
Element Modifier</a>, mais il y en a
d&#x27;autres avec le même but : chaque élément HTML de mes composants doit avoir une
classe CSS qui lui est unique. De cette façon, pas besoin d&#x27;imbrication, et pas
de collision de la cascade !</p>
<p>Et ce code de pré-processeur :</p>
<pre><code class="hljs language-scss"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>

  img {
    border: <span class="hljs-number">1px</span> solid black;
  }
}</code></pre>
<p>se transforme en :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor
}

<span class="hljs-selector-class">.Title-icon</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
}</code></pre>
<p>Évidement, le code HTML doit être mis à jour avec les nouvelles classes, mais
les sélecteurs sont maintenant courts et compréhensibles. Et ceci, sans aucune
chance de collision de cascade.</p>
<p>Maintenant, pour pouvoir mieux expliquer un dernier outil, celui qui je pense va
résoudre tous nos problèmes, il faut que je vous montre une autre approche pour
contourner les problèmes de la cascade :</p>
<h3 id="frameworks-css"><a href="#frameworks-css" class="phenomic-HeadingAnchor">#</a>Frameworks CSS</h3>
<p>Ici, pour éviter à nos règles CSS d&#x27;entrer en collision, nous… n&#x27;en écrivons
plus !
Les frameworks CSS sont des styles déjà écrits qu&#x27;on peut utiliser avec des
classes CSS spécifiques. Il y a deux approches ici :</p>
<ul>
<li>
<p>Les frameworks de styles &quot;finaux&quot; comme <a href="http://getbootstrap.com">Bootstrap</a>.
Il suffit d&#x27;ajouter la classe <code>btn</code> sur un élément HTML et… tada ! C&#x27;est
maintenant un magnifique bouton. Certaines variables sont modifiables pour
transformer le look global du framework.</p>
</li>
<li>
<p>Les frameworks de styles &quot;utilitaires&quot; comme <a href="http://tachyons.io">Tachyons</a>.
Ici, il n&#x27;y a pas de styles pré-définis, mais plein de classes utilitaires
sont disponibles, comme <code>pam</code> pour donner un <em>medium padding</em> à un élément,
ou encore <code>ba</code> pour lui donner une <em>border all</em> tout autour.</p>
</li>
</ul>
<p>Les frameworks utilitaires sont assez intéressants, du fait que le fichier CSS
final fera autour de 10kB et jamais plus, même si le site grandit ! Mais il y
aura beaucoup de classes peu compréhensibles dans le code HTML. C&#x27;est comparable
aux styles inline, avec une optimization de poids final, comme <code>ba</code> est plus
court que <em>“border-style: solid; border-width: 1px;”</em></p>
<p>Ces frameworks nous évitent tout tracas avec la cascade ! Mais je n&#x27;aimais pas
le fait d&#x27;utiliser un framework, ainsi qu&#x27;avoir beaucoup de classes non
compréhensibles dans mon code HTML. Cependant, la totale réutilisabilité et
modularité des styles, sans problèmes de cascade, sont impressionnants.</p>
<p>Cela nous amène donc à cet outil génial, forgé directement avec la meilleure
magie JavaScript :</p>
<h3 id="css-modules"><a href="#css-modules" class="phenomic-HeadingAnchor">#</a>CSS Modules</h3>
<p>Ce concept a d&#x27;abord pris forme suite à une simple observation : de nos jours,
le CSS est compilé à partir d&#x27;autres languages pour permettre une écriture plus
facile, et pour cette même raison le HTML est aussi généré grâce à des outils de
templating en JavaScript. Mais les sélecteurs CSS, le lien entre les éléments et
les styles, ceux-la même auxquels le codeur doit faire très attention pour
éviter qu&#x27;ils n&#x27;entrent en collision, n&#x27;ont pas d&#x27;outils du tout.</p>
<p>Et <a href="https://github.com/css-modules/css-modules">CSS Modules</a> fut créé. La
première fonctionnalité intéressante est la génération automatique des noms de
classes CSS. Plus d&#x27;inquiétude sur leur unicité, on peut les nommer comme on
veut, au final ceux générés dans le HTML seront uniques. Promis. Cela nous
permet de réécrire ce code CSS en BEM, et HTML :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>en ce code CSS et template JavaScript :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName</span> {
  <span class="hljs-attribute">color</span>: $textColor
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.styleName}</span>&gt;&lt;/h1&gt;`</span></code></pre>
<p>Une fois compilé, ce code générera quelque chose comme ça :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"styleName__abc5436"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>Une casc-quoi ? Je ne sais pas ce que c&#x27;est ! ❤️</p>
<p>La deuxième fonctionnalité géniale, directement inspirée par les frameworks CSS
modulaires comme Tachyons, est la composition des styles. De la même façon qu&#x27;en
ajoutant plusieurs classes utilitaires sur son élément HTML, CSS Modules nous
permet de composer nos classes à partir de styles communs. Laissez-moi vous
montrer :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.bigTitle}</span>&gt;&lt;/h1&gt;
 &lt;h2 class=<span class="hljs-subst">${styles.mediumTitle}</span>&gt;&lt;/h2&gt;`</span></code></pre>
<p>va générer :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle__def6547</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle__1638bcd</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js">&lt;h1 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 bigTitle__def6547"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;h2 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 mediumTitle__1638bcd"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre>
<p>Et ceci, messieurs-dames, est plutôt fantastique. Les styles sont modularisables
et composables, et ce sans classes incompréhensibles mais directement dans les
feuilles de style. Et les collisions de sélecteurs et règles ne sont plus qu&#x27;un
mauvais souvenir.</p>
<p>Et c&#x27;est ainsi que j&#x27;ai expérimenté avec le CSS et sa cascade jusque-là.
J&#x27;espère que les mois et les années à venir vont me surprendre avec de meilleurs
outils et / ou méthodologies, et je serais heureux de les apprendre et les
essayer 👍</p>
]]></description><link>http://putaindecode.io/fr/articles/css/modules/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/css/modules/</guid><pubDate>Tue, 23 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Toward CSS modules]]></title><description><![CDATA[<blockquote>
<p>I think that even before I ever knew what it was, I already heard someone
telling me “Oh god, I HATE CSS”. This sentence is often said by one of my
backender friends, and often for very good reasons. This post isn’t going to
defend nor make you embrace CSS , but as front-end tooling is quickly improving,
I find it interesting to explain the new ways of writing it.</p>
</blockquote>
<h2 id="back-to-basics"><a href="#back-to-basics" class="phenomic-HeadingAnchor">#</a>Back to basics</h2>
<p>First, to understand what are the problems that the new tools are attempting to
solve, a small reminder of what CSS is: <em>Cascading Style Sheets</em>.</p>
<p>A style sheet ? Boy, that’s easy ! It’s some code that maps some  “styles” to
HTML elements. Cascading ? Well, sometimes more than one (or no) style can match
for an HTML element, and “cascading” is the set of rules that exist to determine
which one to apply.</p>
<p>Let’s see some basic CSS code: we want our h1 titles to be red.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>Here, we map the <strong><em>rule (or declaration)</em></strong> “color: red” to the <strong><em>selector</em></strong>
“h1”. A selector can contain multiples rules in its declaration block.</p>
<blockquote>
<p>And now the delight dies as we enter the cascade hell.</p>
</blockquote>
<h2 id="the-cascading-thing"><a href="#the-cascading-thing" class="phenomic-HeadingAnchor">#</a>The cascading thing</h2>
<p>The cascade is for me the disaster that makes CSS un-maintainable without
guidelines nor tools when writing it. I’ll show you some examples explaining the
main concepts of the cascade, but they will be quite simple, whereas most web
app nowadays have huge codebases, making the cascade effects bigger.</p>
<p>The need for such a system like the cascade comes from the fact that CSS allows
multiple rules to be applied on the same element, even from different origins
(the website, but also the browser or even from the user). It is therefore
necessary to define what is the rule that ultimately will be applied in this
case.
The cascade gives each rule a weight, calculated from several criteria, and
apply the heaviest on the element.
I could appear simple at first, but the calculations
criteria are not, at all.</p>
<p>The rules that have the lightest cascade weight are not really an issue, but we
have to keep them in mind to avoid surprises:</p>
<h3 id="browser-defaults"><a href="#browser-defaults" class="phenomic-HeadingAnchor">#</a>Browser defaults</h3>
<p>Here is the top of the cascade. These are the rules that makes a h1 title big
even if it isn&#x27;t specified.</p>
<h3 id="parent-inheritance"><a href="#parent-inheritance" class="phenomic-HeadingAnchor">#</a>Parent inheritance</h3>
<p>Then, the rules are inherited from the parents HTML elements. Back to our h1
element, if there is a “color: blue” rule on the body element, the title will
inherit it, and will therefore be blue.</p>
<p>That being said, we now enter a more painful level of cascade weight.</p>
<h3 id="rule-order"><a href="#rule-order" class="phenomic-HeadingAnchor">#</a>Rule order</h3>
<p>The position of a rule compared with others will have an influence on its
weight. Thus, if two rules were to have the same weight if on the same position,
it finally will be the latest that will be the heaviest, and so applied. <strong><em>The
latest.</em></strong> With some quite simple code, it can be easy to understand:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Easy, right ? The h1 will be blue ! But if there is a “color: red” rule in one
CSS file named <em>foo.css</em>, a “color: blue” rule in another file named <em>bar.css</em>,
that the <em>foo.css</em> loading takes more time than <em>bar.css</em>, but that the
<em>foo.css</em> HTML tag is before the <em>bar.css</em> one, which rule is applied ? Well,
it’s quite harder to know. <em>(hint: the loading time is not taken into account)</em></p>
<h3 id="selector-specificity"><a href="#selector-specificity" class="phenomic-HeadingAnchor">#</a>Selector specificity</h3>
<p>This one is a level of complexity higher, <a href="https://specificity.keegan.st">some people even made calculators to
simplify it</a>. I will not enter into much details,
but know that the weight of a selector is equal to the sum of all the weights of
the selectors composing it. And that all selectors does’t weigh the same.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.title</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>In this example, the first selector’s weight is 10 because it only contains a
CSS class selector which weigh 10. The second selector’s weight is 3, because it
contains three tag selectors, weighing each 1. So, as 10 &gt; 3, the h1 title will
be red !</p>
<h3 id="inline-styles"><a href="#inline-styles" class="phenomic-HeadingAnchor">#</a>Inline styles</h3>
<p>The rules that are in the “style” attribute on a HTML element are heavier than
any selector previously defined. Here is a blue title:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<h3 id="importance"><a href="#importance" class="phenomic-HeadingAnchor">#</a>Importance</h3>
<p>And last but not least, the God Mode, the crusher of all styles, the
<strong><em>!important</em></strong> keyword. When we REALLY want our title to be red:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>As all this cascade is about weight, if two rules are marked as !important, the
rest of the criteria is still taken into account to calculate which one is the
heavier, and so applied.</p>
<p><strong>…And that is as bad as it gets.</strong> Now, imagine thousands and thousands of
selectors cascading over themselves to style a website, and you’ll understand
the hell CSS can be. So, some fellow CSS developers imagined several
methodologies and tools to prevent this nightmare to happen !</p>
<h2 id="tooling-evolution"><a href="#tooling-evolution" class="phenomic-HeadingAnchor">#</a>Tooling evolution</h2>
<p>Now I’ll present to you how my way of writing CSS evolved over time. Do not
expect a complete timeline of all the tools invented since the first release of
CSS in 1996 (I was 6 years old !), but a description of how I worked with (or
around) the cascade in my short personal experience.</p>
<h3 id="pre-processors"><a href="#pre-processors" class="phenomic-HeadingAnchor">#</a>Pre-processors</h3>
<p>I began developing web applications in 2012, in the golden age of the
pre-processors. They already had appeared a few years back, as CSS itself wasn’t
enough to build complex websites. Pre-processors are compilers that generate CSS
from slightly different languages, like <a href="http://sass-lang.com">Sass</a> or
<a href="http://lesscss.org">LESS</a>. These new languages added some fantastic new
features as variables or nesting, among other wonders.</p>
<p>We could transform some old and un-easy to maintain CSS:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#E5E5E5</span>;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<p>into this much <em>better</em> version:</p>
<pre><code class="hljs language-scss"><span class="hljs-variable">$textColor</span>: <span class="hljs-number">#333333</span>;

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: lighten(<span class="hljs-variable">$textColor</span>, <span class="hljs-number">90%</span>);

  <span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>
  }
}</code></pre>
<p>With these new tools, and to prevent rules to collide in the cascade, we started
nesting and replicating the whole HTML structure into our Sass or LESS code. Our
CSS ended up with super long and heavy selectors matching only and exactly our
element, like this one:</p>
<blockquote>
<p>.searchPage .sideBar .refinements.default .category .star input</p>
</blockquote>
<p>And this worked pretty well for a time ! But these selectors weren’t the more
efficient, and the HTML structure being doubled, any change in it must be passed
on the styles. So I moved on.</p>
<h3 id="css-methodologies"><a href="#css-methodologies" class="phenomic-HeadingAnchor">#</a>CSS Methodologies</h3>
<p>By this time, some new CSS writing guidelines began to drew my attention. They
weren’t exclusive with pre-processors, and aimed to avoid cascade collision
(just like nesting) with some rules, like on the selector naming.</p>
<p>These methodologies came by the time I started to split my developments into
components. The nesting didn’t work well with these, as the purpose was to
create bits of code usable everywhere in my web app, like a button for example.
The one I use (still today) is named <a href="https://en.bem.info/method/">BEM, for Block Element
Modifier</a>, but there are others with the same aim:
each HTML element of my component has to have an unique CSS class. This way, no
nesting is needed, and no cascade collision !</p>
<p>And this pre-processed code:</p>
<pre><code class="hljs language-scss"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>

  img {
    border: <span class="hljs-number">1px</span> solid black;
  }
}</code></pre>
<p>was transformed into:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor
}

<span class="hljs-selector-class">.Title-icon</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
}</code></pre>
<p>Obviously, the HTML code needed to be updated with the new classes, but the
selectors are now short and self-explanatory ! Without any chance of cascade
collision.</p>
<p>Now, and to better explain a final tool, the one I think will solve all our
problems (for now), I must show you another approach of this “working around”
the cascade:</p>
<h3 id="css-frameworks"><a href="#css-frameworks" class="phenomic-HeadingAnchor">#</a>CSS Frameworks</h3>
<p>Here, to prevent our CSS to collide, we… stop writing our own ! CSS frameworks
are already written styles that we can use with specific CSS classes. There is
two different approaches here:</p>
<ul>
<li>
<p>“Final” styles framework as <a href="http://getbootstrap.com">Bootstrap</a>: a simple
<em>“btn”</em> class on a HTML element and… tada ! Now it is a magnificent button.
Besides, some variables are available to customize the frameworks’ look.
Utility styles framework, like <a href="http://tachyons.io">Tachyons</a>. Here, there
aren’t any pre-defined style, but a lot of utility CSS classes are available,
like <em>“pam”</em> to make an element have a <em>medium padding</em>, or <em>“ba”</em> to make it
have a <em>border all</em> around it.</p>
</li>
<li>
<p>The second one is quite interesting, as our final CSS file will only weigh
10kB and never more, even if the  website grows ! But the HTML will have a lot
of gibberish classes.
It’s comparable with having all the styles inline, with a
weight optimization comparable with minification, as <em>“ba”</em> is shorter than
<em>“border-style: solid; border-width: 1px;”</em>.</p>
</li>
</ul>
<p>These frameworks will keep us from complex CSS cascade calculations ! But I
quite didn’t like the fact to use a framework, and to have a lot of quite
unreadable CSS classes in my HTML. But the full re-usability and modularity of
the styles, without any cascade problems, are awesome.</p>
<p>This bring us to this amazing tool, directly forged with the best JavaScript
magic:</p>
<h3 id="css-modules"><a href="#css-modules" class="phenomic-HeadingAnchor">#</a>CSS Modules</h3>
<p>This concept first took shape from a simple observation: nowadays, the CSS code
is compiled from other languages to make its writing way easier, and for the
same reason HTML code is mainly generated with JavaScript templating tools. But
the CSS selectors, the link between the elements and the styles, the ones for
which the coder really needs to cogitate to prevent them to collide, are not
tooled at all.</p>
<p>And so <a href="https://github.com/css-modules/css-modules">CSS Modules</a> was created.
The first awesome feature is the CSS class names automatic generation. No more
worries about their uniqueness, we can name them as we want, the final one
generated on the HTML element will be unique. Promise. This allows to rewrite
this previous CSS BEM and HTML code:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>into this CSS and JS template code:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName</span> {
  <span class="hljs-attribute">color</span>: $textColor
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.styleName}</span>&gt;&lt;/h1&gt;`</span></code></pre>
<p>And when compiled, this code will generate something like this !</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"styleName__abc5436"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>A casc-what ? I don’t know what this is ! ❤️</p>
<p>The second main feature, which is directly inspired by modular CSS frameworks
like Tachyons, is the styles composition. Just like it allowed to style HTML
elements with some common utility classes, CSS modules allows to compose our
classes with common styles. Let me show you !</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.bigTitle}</span>&gt;&lt;/h1&gt;
 &lt;h2 class=<span class="hljs-subst">${styles.mediumTitle}</span>&gt;&lt;/h2&gt;`</span></code></pre>
<p>will compile into:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle__def6547</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle__1638bcd</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js">&lt;h1 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 bigTitle__def6547"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;h2 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 mediumTitle__1638bcd"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre>
<p>And that, Sir, is pretty awesome. Styles are composable and modularizable, and
not with a lot of gibberish utility classes but directly in the stylesheet. And
styles colliding are just an old nightmare.</p>
<p>That’s how I’ve been playing around with CSS and its cascade until now. I expect
the months and years to come to surprise me with new and better tools or
methodologies, and I’ll be happy to learn and test them 👍.</p>
]]></description><link>http://putaindecode.io/en/articles/css/modules/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/css/modules/</guid><pubDate>Tue, 23 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction à Grid Layout]]></title><description><![CDATA[<p>La mise en page d&#x27;un site ou d&#x27;une application est toujours quelque chose de
complexe et fastidieux à développer/maintenir. Pour cela, de nombreux designs
sont élaborés à partir d&#x27;une grille. En effet, l&#x27;objectif de la grille est de
servir de base pour placer les différents éléments et de faire en sorte qu&#x27;ils
soient alignés et espacés uniformément. Le problème de CSS est qu&#x27;il rencontre
beaucoup de lacunes pour mettre en place cette logique.</p>
<p>L&#x27;arrivée du module <code>Flexbox</code> a commencé à bien faciliter les choses. Toutefois,
ce module n&#x27;est pas adapté à toutes les situations et il est bien plus pertinent
sur du layout de composants.</p>
<p>C&#x27;est pour cette raison qu&#x27;a été développé le module <code>Grid Layout</code>, plus
puissant et orienté mise en page.</p>
<h2 id="État-des-lieux"><a href="#%C3%89tat-des-lieux" class="phenomic-HeadingAnchor">#</a>État des lieux</h2>
<p>Parlons des choses qui fâchent dès le début. À l&#x27;heure actuelle la dernière
révision date du <a href="http://www.w3.org/TR/css-grid-1/">17 septembre 2015</a> et la
spécification en est toujours à l&#x27;état de <em>working draft</em>.</p>
<p>La compatibilité des <a href="http://caniuse.com/#feat=css-grid">navigateurs est quelque peu
limitée</a>. Excepté Internet Explorer 10+ (Edge
également), il est nécessaire d&#x27;activer le flag <code>layout.css.grid.enabled</code> dans
Firefox et <code>experimental Web Platform features</code> pour Chrome pour activer le
support du module.</p>
<p>Autant dire qu&#x27;une utilisation en production est relativement prématurée, quand
bien même cela ne doit pas nous empêcher d&#x27;expérimenter ce module.</p>
<h2 id="grid"><a href="#grid" class="phenomic-HeadingAnchor">#</a>Grid</h2>
<p>La notion de Grid n&#x27;est pas nouvelle, de multiples frameworks/librairies
utilisent déjà la mise en page en <code>Grid</code> :</p>
<ul>
<li><a href="https://github.com/suitcss/components-grid">SUIT CSS components-grid</a></li>
<li><a href="http://foundation.zurb.com/docs/components/grid.html">Zurb Foundation</a></li>
<li><a href="http://960.gs/">960</a></li>
<li><a href="https://github.com/cssrecipes/grid">cssrecipes Grid</a></li>
</ul>
<p>Toutes ces solutions se basent soit sur du <code>inline-block</code>, soit plus récemment
sur <code>Flexbox</code>. Même si elles sont relativement élégantes, elles nécessitent
quand même quelques petits hacks ou tricks pour réussir à faire quelque chose de
cohérent (hello, <code>font-size: 0</code>, gouttière, <code>calc</code> avec marge négative, etc.).
La raison est simple : les techniques utilisées ne sont pas adaptées pour un
système complet de <code>Grid</code>.</p>
<h2 id="thinking-in-grid"><a href="#thinking-in-grid" class="phenomic-HeadingAnchor">#</a>Thinking in Grid</h2>
<p>De façon à pouvoir présenter une partie de la spécification, nous allons partir
sur cette mise en page :</p>
<p><img src="maquette.png" alt="Maquette Grid Layout"></p>
<p>Avant de commencer à présenter les différentes propriétés, réfléchissons au
concept de <code>Grid</code>.</p>
<h3 id="grid-lines"><a href="#grid-lines" class="phenomic-HeadingAnchor">#</a>Grid lines</h3>
<p>Si on applique cette notion à notre maquette, voici ce qu&#x27;on obtient :</p>
<p><img src="grid-line.png" alt="Caniuse Grid Layout"></p>
<p>Concrètement, cela consiste à découper notre interface de façon à pouvoir en
extraire une grille et ainsi virtualiser la position et l&#x27;espace pris pour
chaque élément.</p>
<p>On va donc pouvoir extrapoler notre UI en lignes (<code>rows</code>), en colonnes
(<code>columns</code>), en cellules (<code>cells</code>) et en zones (<code>areas</code>).</p>
<p>Cette dernière notion (<code>areas</code>) est peut-être nouvelle dans la théorie, mais va
s&#x27;avérer très utile dans la pratique pour la suite.</p>
<h2 id="grid-layout"><a href="#grid-layout" class="phenomic-HeadingAnchor">#</a>Grid Layout</h2>
<p>On dispose de suffisamment d&#x27;informations sur notre interface pour démarrer
(enfin) notre intégration.</p>
<p>Voici le markup que l&#x27;on va utiliser pour notre maquette.</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Layout"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Header"</span>&gt;</span>Header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Aside"</span>&gt;</span>Aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Main"</span>&gt;</span>
    Main
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Footer"</span>&gt;</span>Footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Dans un premier temps, nous allons &quot;configurer&quot; notre <code>Grid</code>:</p>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.Layout</span> {
  <span class="hljs-comment">/*
   * On déclare un nouveau contexte dans le parent
   * qui devient alors un grid-container
   * tous les enfants deviennent des grid-items
   */</span>
   <span class="hljs-attribute">display</span>: grid;

  <span class="hljs-comment">/* Configuration de notre canvas */</span>

  <span class="hljs-comment">/*
   * On définit le nombre de colonnes :
   * - la première fera 200px de large
   * - la deuxième fera 10px de large
   * - la troisième prendra tout l'espace restant
   */</span>
   <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1</span>fr;

  <span class="hljs-comment">/*
   * Cette fois-ci au tour des lignes :
   * - la première fera 70px de haut
   * - la deuxième fera 10px de haut
   * - la troisième ligne s'adaptera à la hauteur de son contenu
   * - la quatrième fera 50px de haut
   */</span>
   <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">70px</span> <span class="hljs-number">10px</span> auto <span class="hljs-number">10px</span> <span class="hljs-number">50px</span>;

  <span class="hljs-comment">/*
   * On peut utiliser grid qui est le raccourci
   * des deux propriétés précédentes
   */</span>
   <span class="hljs-attribute">grid</span>: <span class="hljs-number">200px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1</span>fr / <span class="hljs-number">70px</span> <span class="hljs-number">10px</span> auto <span class="hljs-number">10px</span> <span class="hljs-number">50px</span>;
}</code></pre>
<p>Notre <code>Grid</code> est prête, passons au positionnement de nos éléments.</p>
<h2 id="grid-area"><a href="#grid-area" class="phenomic-HeadingAnchor">#</a>grid-area</h2>
<p>Pour notre exemple nous allons utiliser la méthode la plus originale du module à
savoir les <code>areas</code>. L&#x27;interêt de cette méthode est de pouvoir contrôler tant en
terme d&#x27;espace occupé que de positionnement les différentes zones (<code>areas</code>) de
notre grille. On pourrait définir la forme des valeurs de <code>grid-template-areas</code>
comme de l&#x27;<code>ASCII art</code>.</p>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.Layout</span> {
  <span class="hljs-comment">/**
   * 1. Header s'affichera sur 3 colonnes
   * 2. On utilisera le symbole . pour définir un élément
   *    virtuel et ainsi l'utiliser pour définir les gouttières
   * 3. Aside s'affichera sur 1 colonne et 3 lignes
   */</span>
  <span class="hljs-attribute">grid-template-areas</span>:
   <span class="hljs-string">"Header Header Header"</span>  <span class="hljs-comment">/* 1 */</span>
   <span class="hljs-string">".        .      .   "</span>  <span class="hljs-comment">/* 2 */</span>
   <span class="hljs-string">"Aside    .     Main "</span>  <span class="hljs-comment">/* 3 */</span>
   <span class="hljs-string">"Aside    .      .   "</span>  <span class="hljs-comment">/* 3 */</span>
   <span class="hljs-string">"Aside    .    Footer"</span>; <span class="hljs-comment">/* 3 */</span>
}

<span class="hljs-comment">/**
 * 1. Il est donc nécessaire de nommer chaque élément
 *    pour le contrôler dans notre area
 */</span>

<span class="hljs-selector-class">.Header</span> {
  <span class="hljs-attribute">grid-area</span>: Header; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Main</span> {
  <span class="hljs-attribute">grid-area</span>: Main; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Aside</span> {
  <span class="hljs-attribute">grid-area</span>: Aside; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Footer</span> {
  <span class="hljs-attribute">grid-area</span>: Footer; <span class="hljs-comment">/* 1 */</span>
}</code></pre>
<p>Notre intégration est terminée, on constate qu&#x27;avec très peu d&#x27;HTML et de CSS,
on arrive déjà à quelque chose d&#x27;intéressant. Il devient alors très facile de
manipuler et déplacer nos différents éléments en fonction du contexte de notre
application (mobile first, responsive, etc.).</p>
<h2 id="et-cest-pas-fini-"><a href="#et-cest-pas-fini-" class="phenomic-HeadingAnchor">#</a>Et c&#x27;est pas fini !</h2>
<p><code>Grid-Layout</code> dispose d&#x27;une quantité assez impressionnante de propriétés, il
embarque pratiquement toutes les propriétés introduites par <code>Flexbox</code>
(<code>align-items</code>, <code>order</code>, <code>justify-content</code> etc..).</p>
<p>De nouvelles fonctions font leur apparition comme <code>repeat</code> (permet d&#x27;appliquer
des motifs de répétition), mais aussi de nouvelles unités tels que
<code>xfr</code> (fraction de l&#x27;espace restant), <code>min-content</code> (se rapporte à l&#x27;élément le
plus petit), <code>max-content</code> (se rapporte à l&#x27;élément le plus grand). La notion de
<code>subgrid</code> est également présente pour l&#x27;imbrication de grilles.</p>
<p>Il est d&#x27;ailleurs tout à fait possible d&#x27;intégrer une même interface de
plusieurs manières différentes. Si l&#x27;on reprend notre exemple, nous somme partis
sur les propriétés utilisant les <code>areas</code>, mais on aurait très bien pu utiliser
<code>grid-row</code> et <code>grid-column</code> qui s&#x27;appliquent non pas sur le parent mais sur les
enfants. Cette solution peut s&#x27;avérer très pratique pour des systèmes de grilles
classiques.</p>
<p><code>Grid Layout</code> est un module très puissant et très complet. En le combinant avec
<code>Flexbox</code>, on dispose de suffisament d&#x27;outils pour travailler sur des mises en
pages complexes. Reste plus qu&#x27;aux navigateurs à rapidement valider/intégrer/supporter
cette nouvelle spécification.</p>
]]></description><link>http://putaindecode.io/fr/articles/css/grilles/grid-layout/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/css/grilles/grid-layout/</guid><pubDate>Tue, 05 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les Proxy]]></title><description><![CDATA[<h2 id="proxies-origin"><a href="#proxies-origin" class="phenomic-HeadingAnchor">#</a>Proxies Origin</h2>
<h3 id="what-the-dom"><a href="#what-the-dom" class="phenomic-HeadingAnchor">#</a>What the DOM?</h3>
<p>ES5 avait laissé un petit trou nommé
<em><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.8">&quot;host objects&quot;</a></em>
afin de donner un &quot;cadre légal&quot; aux trucs bizarres qui peuvent arriver dans le
DOM. Par exemple, certaines collections sont dites
<a href="https://dom.spec.whatwg.org/#concept-collection-live">&quot;live&quot;</a> et même si on ne
touche pas l&#x27;objet directement, on se rend compte que la collection a été
modifiée.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> childNodes = <span class="hljs-built_in">document</span>.body.childNodes;
<span class="hljs-built_in">console</span>.log(childNodes.length); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))
<span class="hljs-comment">// Personne n'a touché explicitement l'objet dans la variable divs, pourtant :</span>
<span class="hljs-built_in">console</span>.log(childNodes.length); <span class="hljs-comment">// 1, wat!</span></code></pre>
<p>Ce genre de comportement n&#x27;est pas explicable par la sémantique d&#x27;ES5 (à moins
d&#x27;accepter des gros problèmes de performances qui consisteraient à ce que le
DOM garde une référence vers toutes les collections live et les mette à jour
régulièrement, ou des getter partout, etc.). La
<a href="https://heycam.github.io/webidl/">spec WebIDL</a> qui fait le lien entre les
objets décrits dans les spec W3C et la sémantique ECMAScript se contentait d&#x27;un
&quot;c&#x27;est un <em>host object</em>, allé, salut les gars les filles !&quot; (en fait, c&#x27;était
pire que ça :
<a href="http://www.w3.org/TR/DOM-Level-2-Core/ecma-script-binding.html">la spec de
l&#x27;époque</a>
était absurde tant elle manquait de détails, mais je vous fais la version de
Noël).</p>
<p>Mais ce genre d&#x27;explication n&#x27;est pas vraiment acceptable. Et si un navigateur
a un bug, comment je polyfille le comportement correct, hein ?</p>
<p>Les proxies peuvent aider.</p>
<h3 id="quest-il-arrivé-à-mon-objet-"><a href="#quest-il-arriv%C3%A9-%C3%A0-mon-objet-" class="phenomic-HeadingAnchor">#</a>Qu&#x27;est-il arrivé à mon objet ?</h3>
<p>Avant que la planète JS ne s&#x27;amourache des
<a href="https://facebook.github.io/immutable-js/">structures des données immutables</a>,
on créait des objets et des fois, on les passait à du code qui les modifiait et
on se demandait bien quand/comment l&#x27;objet en question en était arrivé dans cet
état. Depuis ES5, on peut logger dans des <em>getters</em> et <em>setters</em>, mais on ne
peut pas savoir quand on s&#x27;est pris un <code>delete</code> ou un
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze</a> ;
on peut constater le résultat, mais c&#x27;est dur de remonter à la source.</p>
<p>Les proxies peuvent aider.</p>
<h3 id="laisse-mon-objet-tranquille-"><a href="#laisse-mon-objet-tranquille-" class="phenomic-HeadingAnchor">#</a>Laisse mon objet tranquille !</h3>
<p>La sémantique des objets tel qu&#x27;on les utilise permet à différents scripts
d&#x27;agir sur les mêmes objets, mais d&#x27;une manière qui ne permet pas forcément
toujours un contrôle fin. Par exemple, si je donne accès à la référence d&#x27;un
objet à quelqu&#x27;un, il possède cette référence pour toujours et dans la foulée
tous les droits associés (donc modifier l&#x27;objet arbitrairement souvent) ; il
n&#x27;est pas possible de <strong>révoquer</strong> l&#x27;accès dans le temps. Ce script a aussi
accès à toutes les propriétés de l&#x27;objet, même si on voudrait n&#x27;en partager
que certaines ; il n&#x27;est pas facile <strong>d&#x27;atténuer</strong> les droits à un objet (sans
créer de nouveaux objets et de se lancer dans des synchronisations coûteuses).</p>
<h2 id="les-proxies-comment-ça-marche"><a href="#les-proxies-comment-%C3%A7a-marche" class="phenomic-HeadingAnchor">#</a>Les proxies, comment ça marche</h2>
<p>Un <strong>proxy</strong> est un nouvel objet (on ne peut pas transformer un objet en un
proxy) qui &quot;emballe&quot; (<em>wrap</em>) un objet existant, la <strong>target</strong> et décrit le
comportement du proxy via un objet appelé le <strong>handler</strong> qui définit les
<em>traps</em> du proxy.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = {a:<span class="hljs-number">1</span>};

<span class="hljs-keyword">const</span> handler = {
    get(target, prop){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"It's a (get) trap!"</span>, prop, target[prop]);
        <span class="hljs-keyword">return</span> target[prop]+<span class="hljs-number">1</span>;
    }
}

<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-built_in">console</span>.log(proxy.a);</code></pre>
<p>console output:</p>
<pre><code>It&#x27;s a (get) trap! a 1 // inside the trap
2 // new value modified by the trap
</code></pre>
<h3 id="liste-des-traps"><a href="#liste-des-traps" class="phenomic-HeadingAnchor">#</a>Liste des traps</h3>
<p>L&#x27;exemple ci-dessus montre la trap <code>get</code>. Voici la liste des traps
disponible :</p>
<ul>
<li>
<p>getPrototypeOf</p>
<ul>
<li>pour <code>Object.getPrototypeOf</code></li>
</ul>
</li>
<li>
<p>setPrototypeOf</p>
<ul>
<li>pour <code>Object.setPrototypeOf</code></li>
</ul>
</li>
<li>
<p>isExtensible</p>
<ul>
<li>pour <code>Object.isExtensible</code></li>
</ul>
</li>
<li>
<p>preventExtensions</p>
<ul>
<li>pour <code>Object.preventExtensions</code></li>
</ul>
</li>
<li>
<p>getOwnPropertyDescriptor</p>
<ul>
<li>pour <code>Object.getOwnPropertyDescriptor</code></li>
</ul>
</li>
<li>
<p>defineProperty</p>
<ul>
<li>pour <code>Object.defineProperty</code></li>
</ul>
</li>
<li>
<p>has</p>
<ul>
<li>pour l&#x27;opérateur <code>in</code></li>
</ul>
</li>
<li>
<p>get</p>
<ul>
<li>pour <em>getter</em> une propriété</li>
</ul>
</li>
<li>
<p>set</p>
<ul>
<li>pour <em>setter</em> une propriété</li>
</ul>
</li>
<li>
<p>deleteProperty</p>
<ul>
<li>pour l&#x27;opérateur <code>delete</code></li>
</ul>
</li>
<li>
<p>enumerate</p>
<ul>
<li>pour les <code>for...in</code> et <code>Object.keys</code></li>
</ul>
</li>
<li>
<p>ownKeys</p>
<ul>
<li>pour <code>Object.getOwnPropertyNames</code></li>
</ul>
</li>
<li>
<p>apply</p>
<ul>
<li>pour quand on appelle le proxy comme une fonction.</li>
</ul>
</li>
<li>
<p>construct</p>
<ul>
<li>pour quand on appelle le proxy comme un constructeur (avec <code>new</code>).</li>
</ul>
</li>
</ul>
<p>Le lecteur attentif aura remarqué que cette liste (et les signatures des
fonctions) correspondent à l&#x27;API</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect#Methods">Reflect</a></p>
<h2 id="solutions-aux-problèmes-précédents"><a href="#solutions-aux-probl%C3%A8mes-pr%C3%A9c%C3%A9dents" class="phenomic-HeadingAnchor">#</a>Solutions aux problèmes précédents</h2>
<h3 id="logger-les-opérations"><a href="#logger-les-op%C3%A9rations" class="phenomic-HeadingAnchor">#</a>Logger les opérations</h3>
<p>Vous voulez savoir quand on objet se prend un <code>delete</code> ? Rien de plus
facile !</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({b: <span class="hljs-number">2</span>}, {
    deleteProperty(target, prop){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Wow, someone just deleted'</span>, prop);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(target, prop);
    },
    freeze(target){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Wow, someone just froze the object'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.freeze(target);
    }
})

<span class="hljs-keyword">delete</span> p.b;
<span class="hljs-built_in">Object</span>.freeze(p);</code></pre>
<h3 id="implémenter-des-nodelist-live"><a href="#impl%C3%A9menter-des-nodelist-live" class="phenomic-HeadingAnchor">#</a>Implémenter des NodeList live</h3>
<p>Ici, on prétend réimplémenter une collection DOM <em>live</em>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildNodesLiveCollection</span>(<span class="hljs-params">parent</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, prop</span>)</span>{
            <span class="hljs-keyword">if</span>(prop === <span class="hljs-string">"length"</span>){
                <span class="hljs-comment">// l'astuce qui n'est pas de la triche , c'est qu'on va</span>
                <span class="hljs-comment">// chercher la valeur au moment de l'appel</span>
                <span class="hljs-keyword">return</span> parent.childNodes.length;
            }
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> target[prop];
        }
    })

}


<span class="hljs-keyword">var</span> liveChildNodes = getChildNodesLiveCollection(<span class="hljs-built_in">document</span>.body);
<span class="hljs-built_in">console</span>.log(liveChildNodes.length); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))
<span class="hljs-built_in">console</span>.log(liveChildNodes.length); <span class="hljs-comment">// 1, magie magie !</span></code></pre>
<h3 id="atténuation"><a href="#att%C3%A9nuation" class="phenomic-HeadingAnchor">#</a>Atténuation</h3>
<p>J&#x27;ai un objet avec plein de propriété et je veux en partager une version
atténuée à une bibliothèque en laquelle je n&#x27;ai qu&#x27;une confiance partielle.</p>
<pre><code class="hljs language-js">// On va se faire MitM avec ce HTTP sans 'S' !
import dubiousLib from 'http://dubious-lib.com/main.js';

const myImportantObject = {
    jfkKillerName: '...',
    elvisGeoloc: {
        long: '...',
        lat: '...'
    },
    name: "David Bruant",
    xmasPresentList: [
        "Raspberry Pi B",
        "Nouveau téléphone (mais pas FirefoxOS, parce qu'ils arrêtent les
téls)",
        "Une boîte de Tic Tac"
    ]
}

function makeWhitelistProxy(t, whitelist){
    return new Proxy(t, {
        get(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.get(target, prop);
        },
        set(target, prop, value){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.set(target, prop, value);
        },
        getOwnPropertyDescriptor(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        deleteProperty(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.deleteProperty(target, prop);
        },
        defineProperty(target, prop, desc){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.defineProperty(target, prop, desc);
        },
        has(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.has(target, prop);
        }
    })
}

const attenatedObject = makeWhitelistProxy(
    myImportantObject,
    new Set(["name", "xmasPresentList"])
);

console.log(myImportantObject.name === attenatedObject.name);
console.log(myImportantObject.jfkKillerName); // "..."
console.log(attenatedObject.jfkKillerName);
// error thrown! 'Error: Attempt to access forbidden property'

dubiousLib(attenatedObject);</code></pre>
<p>On peut imaginer d&#x27;autres formes d&#x27;atténuation, comme ne donner accès qu&#x27;en
lecture à l&#x27;objet alors que l&#x27;on garde soi-même un accès en écriture (ce qui
est impossible avec <code>Object.freeze</code>).</p>
<h3 id="révocation"><a href="#r%C3%A9vocation" class="phenomic-HeadingAnchor">#</a>Révocation</h3>
<p>On peut révoquer l&#x27;accès à un objet en implémentant le <em>pattern</em> &quot;caretaker&quot;</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCaretaker</span>(<span class="hljs-params">t</span>)</span>{
    <span class="hljs-keyword">return</span> {
        revoke(){
            t = <span class="hljs-literal">undefined</span>;
        },
        proxy: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(t, {
            get(target, prop){
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop);
            },
            set(target, prop, value){
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, value);
            }
            <span class="hljs-comment">// flemme d'écrire et vous faire lire les autres traps,</span>
            <span class="hljs-comment">// mais faut toutes les faire ;-)</span>
        })
    }
}

<span class="hljs-keyword">const</span> o = {};
<span class="hljs-keyword">const</span> {revoke, proxy} = makeCaretaker(o);

proxy.a = <span class="hljs-number">12</span>;

<span class="hljs-built_in">console</span>.log(o.a, proxy.a); <span class="hljs-comment">// 12 12</span>

proxy.b = <span class="hljs-number">37</span>;
<span class="hljs-keyword">delete</span> proxy.a;

revoke();

proxy.b; <span class="hljs-comment">// BOOM! TypeError: target is not a non-null object</span></code></pre>
<h4 id="via-un-meta-proxy"><a href="#via-un-meta-proxy" class="phenomic-HeadingAnchor">#</a>...via un meta-proxy</h4>
<p>La petite astuce rigolote avec les proxy, vu que l&#x27;API est dite <em>stratifiée</em>,
c&#x27;est que vu que le handler est un objet, on pourrait en faire un proxy pour
implémenter la révocation plus simplement.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCaretaker</span>(<span class="hljs-params">target</span>)</span>{
    <span class="hljs-keyword">const</span> metaHandler = {
        get(handler, trapName){
            <span class="hljs-keyword">if</span>(!target)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Revoked object!'</span>)
            <span class="hljs-keyword">else</span>
                <span class="hljs-comment">// Le miroir entre les traps et l'API Reflect vient de là ;-)</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>[trapName];
        }
    }

    <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, metaHandler);

    <span class="hljs-keyword">return</span> {
        revoke(){
            target = <span class="hljs-literal">undefined</span>;
        },
        proxy: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)
    };
}

<span class="hljs-keyword">const</span> o = {};
<span class="hljs-keyword">const</span> {revoke, proxy} = makeCaretaker(o);

proxy.a = <span class="hljs-number">12</span>;

<span class="hljs-built_in">console</span>.log(o.a, proxy.a); <span class="hljs-comment">// 12 12</span>

proxy.b = <span class="hljs-number">37</span>;
<span class="hljs-keyword">delete</span> proxy.a;

revoke();

proxy.b; <span class="hljs-comment">// BOOM! TypeError: target is not a non-null object</span></code></pre>
<p>Il fait mal au crâne au début celui-là, mais après relecture, on se sent bien.</p>
<p>Pour des raisons par très intéressantes, les proxy révocables sont fournis
directement via</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable">Proxy.revocable</a>,
donc, pas besoin de se fatiguer à le coder avec toutes les traps ou avec un
meta handler.</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Les proxies sont un outil bas niveau et puissant. Avec de grands pouvoirs
viennent de grandes responsabilités, alors comprenez bien cet outil avant de
vouloir l&#x27;utiliser partout.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/proxy/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/proxy/</guid><pubDate>Fri, 18 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : symbols]]></title><description><![CDATA[<p>Following its goal of enriching primitive types, ES6 introduces symbols.
Familiar to developers in many langages, especially Ruby, symbols bring us a
step further towards the eradication of <em>stringly-typed programming</em>. Symbols
provide us with a more robust way to encode identifiers.</p>
<h2 id="creating-symbols"><a href="#creating-symbols" class="phenomic-HeadingAnchor">#</a>Creating Symbols</h2>
<p>The <code>Symbol()</code> function lets us create new symbols:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// A simple symbol</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">typeof</span> mySymbol === <span class="hljs-string">'symbol'</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// A symbol with a label</span>
<span class="hljs-keyword">const</span> myOtherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"label"</span>);


<span class="hljs-comment">// Each symbol is unique</span>
<span class="hljs-keyword">const</span> yetAnotherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"label"</span>);
yetAnotherSymbol === myOtherSymbol; <span class="hljs-comment">// false</span></code></pre>
<p>Each symbol created with <code>Symbol</code> is both unique and immutable. This allows to
avoid collisions: it&#x27;s impossible to mistakenly have two identical symbols.</p>
<h2 id="implement-an-enum-with-symbols"><a href="#implement-an-enum-with-symbols" class="phenomic-HeadingAnchor">#</a>Implement an <em>enum</em> with symbols</h2>
<p>Instead of using strings as possible values for an <em>enum</em>, it&#x27;s possible to
use symbols.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ANIMAL_DOG = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> ANIMAL_CAT = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDescription</span>(<span class="hljs-params">animal</span>) </span>{
  <span class="hljs-keyword">switch</span>(animal) {
    <span class="hljs-keyword">case</span> ANIMAL_DOG:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Loving animal"</span>;
    <span class="hljs-keyword">case</span> ANIMAL_CAT:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Evil, sadistic animal"</span>;
  }
}</code></pre>
<p>This way, there is no risk of mistakenly mixing a user-provided string with an
<em>enum</em>. This forces the value through a verifying and parsing stage.</p>
<h2 id="symbols-as-keys"><a href="#symbols-as-keys" class="phenomic-HeadingAnchor">#</a>Symbols as keys</h2>
<p>We can use symbols as a key in an object or in a class.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKey = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"MY_KEY"</span>);

<span class="hljs-keyword">const</span> myMutableObject = {};
myMutableObject[myKey] = <span class="hljs-string">"a value"</span>;

<span class="hljs-comment">// With *computed property keys*</span>
<span class="hljs-keyword">const</span> myObj = {
    [myKey]: <span class="hljs-string">"a value"</span>
}</code></pre>
<p>Due to symbols unicity, no more collisions between the keys of an object.
The user can extend objects without having properties overriden by mistake.</p>
<p>For instance, the iterator on an object (used by <code>for..of</code>), is a property
whose key is a symbol, available through <code>Symbol.iterator</code>.</p>
<p>For instance, an object&#x27;s iterator (used by <code>for..of</code>) is made available as
the property indexed by <code>Symbol.iterator</code>, a symbol devised for this use.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myIterableObject = {
  * [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Three"</span>;
  }
}

<span class="hljs-comment">// Displays One, Two and Three</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> myIterableObject) {
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-comment">// Blows up with 'TypeError: undefined is not a function'</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> {}) {}</code></pre>
<p>Several symbols (called <em>well-known symbols</em>) index behaviour defining
object properties: <code>Symbol.iterator</code> for the iterator on an object&#x27;s
values, <code>Symbol.hasInstance</code> to alter the result of <code>instanceof</code>, …</p>
<p>These properties are therefore protected against tampering.</p>
<h3 id="differences-between-symbol-keys-and-string-keys"><a href="#differences-between-symbol-keys-and-string-keys" class="phenomic-HeadingAnchor">#</a>Differences between symbol keys and string keys</h3>
<p>Properties indexed by symbols are not available from the commonly used key or
values functions.</p>
<h4 id="list-symbol-keys"><a href="#list-symbol-keys" class="phenomic-HeadingAnchor">#</a>List symbol keys</h4>
<p>Properties indexed by symbols are not visited by <code>for..in</code>, nor listed by
<code>Object.keys</code>, or <code>Object.getOwnPropertyNames</code>. However, they are listed by
<code>Object.getOwnPropertySymbols</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myObject = {
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}

<span class="hljs-built_in">Object</span>.getOwnPropertyNames(myObject) <span class="hljs-comment">// [ "key" ]</span>
<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(myObject) <span class="hljs-comment">// [ Symbol() ]</span></code></pre>
<p>This way, a piece of code written with <code>Object.getOwnPropertyNames</code> -- and
expecting strings -- won&#x27;t be broken by the use of symbols as keys.</p>
<h4 id="jsonstringify"><a href="#jsonstringify" class="phenomic-HeadingAnchor">#</a><code>JSON.stringify</code></h4>
<p>Symbol-indexed properties are ignored by <code>JSON.stringify</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">JSON</span>.stringify({
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}) <span class="hljs-comment">// '{"key":"string-keyed value"}'</span></code></pre>
<h2 id="global-symbol-registry"><a href="#global-symbol-registry" class="phenomic-HeadingAnchor">#</a>Global symbol registry</h2>
<p>Symbols being unique, one cannot create a new symbol that is equal to an
already existing one. To be useful, a symbol must be somehow accessible. It&#x27;s
also possible to create a symbol in a global registry with <code>Symbol.for</code>, to
make it available from anywhere.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Returns a symbol, creating it if it doesn't already exist</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>)

mySymbol === <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// It's possible to get the key indexing a symbol in the registry</span>
<span class="hljs-built_in">Symbol</span>.keyFor(mySymbol) <span class="hljs-comment">// 'mySymbol'</span>

<span class="hljs-comment">// Symbols not created in the registry are not available in it</span>
<span class="hljs-built_in">Symbol</span>.keyFor(<span class="hljs-built_in">Symbol</span>()) <span class="hljs-comment">// undefined</span></code></pre>
<p><code>Symbol.for</code> allows to share symbols everywhere in the code, including
different execution contexts (different frames).</p>
<h2 id="support"><a href="#support" class="phenomic-HeadingAnchor">#</a>Support</h2>
<p>In browsers, symbols are supported since Chrome 38, Firefox 36, Opera 25 and
Safari 9. Nothing in Internet Explorer. Babel support is limited.</p>
<p>In Node.js, symbols are supported since version <code>0.12</code>.</p>
<p>Some <em>well-known symbols</em> are not available on all platforms. This depends on
implemented features support.</p>
<h2 id="round-up"><a href="#round-up" class="phenomic-HeadingAnchor">#</a>Round up</h2>
<p>Symbols are a way to create unique tokens, which is way more robust than
using strings. Using symbols to implement <em>enums</em> prevents collisions and
unwanted mix-up with unqualified data.</p>
<p>Lastly, symbols as object keys prevent collisions and lets us have
<em>meta-properties</em> cleanly separated from regular, string-indexed properties.
Properties indexed with symbols can&#x27;t be read, modified or listed by mistake.
This offers some protection against tampering.</p>
<h2 id="further-reading"><a href="#further-reading" class="phenomic-HeadingAnchor">#</a>Further reading</h2>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN documentation on symbols</a></li>
<li><a href="http://www.2ality.com/2014/12/es6-symbols.html">Thorough article on how symbols work and how they can be used</a></li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/symbols/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/symbols/</guid><pubDate>Thu, 17 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les symboles]]></title><description><![CDATA[<p>Dans sa politique d&#x27;enrichissement des types primitifs, ES6 introduit les
symboles. Chers aux développeurs de nombreux langages, Ruby en tête, les
symboles constituent une étape de plus vers l&#x27;éradication du <em>stringly-typed
programming</em>. En effet, les symboles fournissent un moyen plus robuste de
représenter des identifiants.</p>
<h2 id="créer-un-symbole"><a href="#cr%C3%A9er-un-symbole" class="phenomic-HeadingAnchor">#</a>Créer un symbole</h2>
<p>La fonction <code>Symbol()</code> permet de créer de nouveaux symboles :</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Un symbole tout bête</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">typeof</span> mySymbol === <span class="hljs-string">'symbol'</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Un symbole avec une description</span>
<span class="hljs-keyword">const</span> myOtherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"description"</span>);


<span class="hljs-comment">// Chaque symbole est unique</span>
<span class="hljs-keyword">const</span> yetAnotherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"description"</span>);
yetAnotherSymbol === myOtherSymbol; <span class="hljs-comment">// false</span></code></pre>
<p>Chaque symbole créé avec <code>Symbol</code> est unique et immutable. Cela permet
d&#x27;éviter les collisions : on ne peut pas avoir deux symboles identiques par
erreur.</p>
<h2 id="utiliser-les-symboles-pour-limplémentation-dun-enum"><a href="#utiliser-les-symboles-pour-limpl%C3%A9mentation-dun-enum" class="phenomic-HeadingAnchor">#</a>Utiliser les symboles pour l&#x27;implémentation d&#x27;un <em>enum</em></h2>
<p>Plutôt que d&#x27;utiliser des chaînes de caractères comme valeurs possible d&#x27;un
<em>enum</em>, on peut utiliser des symboles.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ANIMAL_DOG = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> ANIMAL_CAT = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDescription</span>(<span class="hljs-params">animal</span>) </span>{
  <span class="hljs-keyword">switch</span>(animal) {
    <span class="hljs-keyword">case</span> ANIMAL_DOG:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Loving animal"</span>;
    <span class="hljs-keyword">case</span> ANIMAL_CAT:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Evil, sadistic animal"</span>;
  }
}</code></pre>
<p>De cette manière, on ne risque pas de mélanger accidentellement une chaine de
caractères fournie par l&#x27;utilisateur et la valeur d&#x27;un <em>enum</em>. On est obligé
de passer par une phase de parsing et de vérification.</p>
<h2 id="utiliser-un-symbole-comme-clé"><a href="#utiliser-un-symbole-comme-cl%C3%A9" class="phenomic-HeadingAnchor">#</a>Utiliser un symbole comme clé</h2>
<p>Il est possible d&#x27;employer des symboles comme clés d&#x27;un objet ou d&#x27;une classe.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKey = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"MY_KEY"</span>);

<span class="hljs-keyword">const</span> myMutableObject = {};
myMutableObject[myKey] = <span class="hljs-string">"a value"</span>;

<span class="hljs-comment">// En utilisant les *computed property keys*</span>
<span class="hljs-keyword">const</span> myObj = {
    [myKey]: <span class="hljs-string">"a value"</span>
}</code></pre>
<p>Grâce à l&#x27;unicité des symboles, plus de problèmes de collision entre les clés
d&#x27;un objet. On peut laisser l&#x27;utilisateur étendre des objets sans prendre le
risque d&#x27;avoir des propriétés écrasées par erreur.</p>
<p>Par exemple, l&#x27;itérateur d&#x27;un objet employé par <code>for..of</code> est une propriété
qui a pour clé un symbole, accessible via <code>Symbol.iterator</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myIterableObject = {
  * [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Three"</span>;
  }
}

<span class="hljs-comment">// Affichera One, Two et Three</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> myIterableObject) {
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-comment">// Plantera avec 'TypeError: undefined is not a function'</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> {}) {}</code></pre>
<p>Différents symboles (les <em>well-known symbols</em>) sont disponibles pour indexer
des propriétés qui personnalisent le comportement des objets :
<code>Symbol.iterator</code> pour itérer sur les valeurs d&#x27;un objet, <code>Symbol.hasInstance</code>
pour modifier le retour de <code>instanceof</code>, …</p>
<p>Ces propriétés sont ainsi protégées contre tout accès involontaire.</p>
<h3 id="différences-avec-lutilisation-dune-chaine-de-caractères-comme-clé"><a href="#diff%C3%A9rences-avec-lutilisation-dune-chaine-de-caract%C3%A8res-comme-cl%C3%A9" class="phenomic-HeadingAnchor">#</a>Différences avec l&#x27;utilisation d&#x27;une chaine de caractères comme clé</h3>
<p>Les propriétés indexées par des symboles ne sont pas accessibles depuis les
fonctions habituellement utilisées pour itérer sur les propriétés ou les
valeurs.</p>
<h4 id="Énumération"><a href="#%C3%89num%C3%A9ration" class="phenomic-HeadingAnchor">#</a>Énumération</h4>
<p>Les propriétés indexées par des symboles ne sont pas visitées par <code>for..in</code>,
ni listées par <code>Object.keys</code> ni <code>Object.getOwnPropertyNames</code>. En revanche,
elles sont listées par <code>Object.getOwnPropertySymbols</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myObject = {
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}

<span class="hljs-built_in">Object</span>.getOwnPropertyNames(myObject) <span class="hljs-comment">// [ "key" ]</span>
<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(myObject) <span class="hljs-comment">// [ Symbol() ]</span></code></pre>
<p>Ainsi, du code utilisant <code>Object.getOwnPropertyNames</code> et s&#x27;attendant à
recevoir des chaînes de caractères ne sera pas cassé par l&#x27;utilisation de
symboles en tant que clés.</p>
<h4 id="jsonstringify"><a href="#jsonstringify" class="phenomic-HeadingAnchor">#</a><code>JSON.stringify</code></h4>
<p>Les propriétés indexées par un symbole sont ignorées par <code>JSON.stringify</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">JSON</span>.stringify({
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}) <span class="hljs-comment">// '{"key":"string-keyed value"}'</span></code></pre>
<h2 id="registre-global-des-symboles"><a href="#registre-global-des-symboles" class="phenomic-HeadingAnchor">#</a>Registre global des symboles</h2>
<p>Un symbole est unique, une fois créé, il est impossible d&#x27;en créér un autre
ayant les mêmes propriétés. Il faut donc que le symbole créé soit accessible
d&#x27;une manière ou d&#x27;une autre pour pouvoir l&#x27;employer. En revanche, il est
possible de créer un symbole dans un registre global accessible de n&#x27;importe
où, grâce à <code>Symbol.for</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Renvoie un symbole, en le créant s'il n'existe pas déjà</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>)

mySymbol === <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Il est possible de récupérer la clé avec laquelle un symbole a été inséré</span>
<span class="hljs-comment">// dans le registre</span>
<span class="hljs-built_in">Symbol</span>.keyFor(mySymbol) <span class="hljs-comment">// 'mySymbol'</span>

<span class="hljs-comment">// Un symbole non créé dans le registre n'est pas disponible</span>
<span class="hljs-built_in">Symbol</span>.keyFor(<span class="hljs-built_in">Symbol</span>()) <span class="hljs-comment">// undefined</span></code></pre>
<p><code>Symbol.for</code> permet donc de partager des symboles partout dans le code, y
compris dans des contextes d&#x27;exécution différents (différentes frames).</p>
<h2 id="support"><a href="#support" class="phenomic-HeadingAnchor">#</a>Support</h2>
<p>Côté navigateur, les symboles sont supportés depuis Chrome 38, Firefox 36,
Opera 25 et Safari 9. Rien chez Internet Explorer. Le support Babel est
limité.</p>
<p>Côté Node.js, le support des symboles est là depuis la version <code>0.12</code>.</p>
<p>Les <em>well-known symbols</em> ne sont pas tous disponibles sur les différentes
plates-formes, leur présence dépendant des fonctionnalités auxquelles ils sont
liés.</p>
<h2 id="pour-résumer"><a href="#pour-r%C3%A9sumer" class="phenomic-HeadingAnchor">#</a>Pour résumer</h2>
<p>Les symboles fournissent un moyen de créer des tokens uniques, ce qui est bien
plus robuste que l&#x27;utilisation de chaînes de caractères. L&#x27;utilisation des
symboles pour représenter les valeurs d&#x27;un <em>enum</em> permet d&#x27;éviter les
collisions et le mélange avec des données non qualifiées.</p>
<p>En tant que clés d&#x27;un objet, les symboles permettent d&#x27;éviter les collisions
et d&#x27;avoir des <em>méta-propriétés</em> séparées et indépendantes des propriétés
indexées par des clés. Les propriétés indexées par des symboles ne peuvent pas
être lues, modifiées ou listées par erreur, ce qui leur offre un certain degré
de protection contre des manipulations accidentelles.</p>
<h2 id="pour-aller-plus-loin"><a href="#pour-aller-plus-loin" class="phenomic-HeadingAnchor">#</a>Pour aller plus loin</h2>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol">La documentation des symboles sur MDN</a></li>
<li><a href="http://www.2ality.com/2014/12/es6-symbols.html">Un article complet sur le fonctionnement des symboles et leur cas
d&#x27;utilisation</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/symbols/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/symbols/</guid><pubDate>Thu, 17 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : for..of loop]]></title><description><![CDATA[<h2 id="introduction"><a href="#introduction" class="phenomic-HeadingAnchor">#</a>Introduction</h2>
<p>With the arrival of new iterable objects, ECMAScript had to create new ways to read through them.
In the unique concern of maintaining the backward compatibility, ES6 had to const his <code>for..in</code> loop untouched.</p>
<blockquote>
<p>But then, how to create a copycat of this same loop with improved capabilities ?</p>
</blockquote>
<p>Solution is quite simple: &quot;Welcome to the <code>of</code> keyword!&quot;</p>
<p>But before I tell you more, and to fully understand the usefulness of this new keyword, const review the existing.</p>
<h2 id="the-good-ol-forin"><a href="#the-good-ol-forin" class="phenomic-HeadingAnchor">#</a>The good ol&#x27; <code>for..in</code></h2>
<p>All self-respecting <em>JavaScript enthousiast</em> already knows the famous <code>for..in</code> loop
whose first value is to iterate over the different keys of an object or an array.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>The <code>for..in</code> loop, despite its ease of use hide some pitfalls:</p>
<ul>
<li>
<p>When itarating over an array, index value is parsed to string : &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, etc..
This behaviour can lead to potential error when index is used in computation.</p>
</li>
<li>
<p>The loop iterate across all the table keys, but also over each of its properties.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>];
arr.oups = <span class="hljs-string">'baz'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + arr[key] ); <span class="hljs-comment">// '0-&gt;foo', '1-&gt;bar', 'oups-&gt;baz'</span>
}</code></pre>
</li>
<li>
<p>Iteration order over a given object properties may vary across depending on the code executing environment.</p>
</li>
</ul>
<h2 id="the-alternative-foreach-method"><a href="#the-alternative-foreach-method" class="phenomic-HeadingAnchor">#</a>The alternative <code>.forEach()</code> method</h2>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.prototype.forEach()</code></a>
loop allow a more secure iteration, but bring other downsides as:</p>
<ul>
<li>Impossibility to halt the loop with the traditional <code>break;</code> and <code>return;</code> statements.</li>
<li>Array only dedicated method.</li>
</ul>
<h2 id="forof-to-the-rescue"><a href="#forof-to-the-rescue" class="phenomic-HeadingAnchor">#</a><code>for..of</code> to the rescue</h2>
<p>ECMA consortium has so decided to proceed with establishment of a new enhanced version of the <code>for..in</code> loop.
Thus was born the <code>for..of</code> loop which, from now on, will coexist with the previous one allowing to maintain
the backward compatibility with former version of the standard.</p>
<p>The principal is the same : run across any type of <em>iterable object</em>.</p>
<p>In its simplest form, the <code>for..of</code> loop therefore allow to iterate over all values of a table keys.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>The <code>for..of</code> loop can also iterate over more complex types like:</p>
<h3 id="strings"><a href="#strings" class="phenomic-HeadingAnchor">#</a><em>Strings</em></h3>
<p>In this case, each character is evaluated as a Unicode entity.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="nodelist"><a href="#nodelist" class="phenomic-HeadingAnchor">#</a><em>NodeList</em></h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// Note: This will only work in platforms that have</span>
<span class="hljs-comment">// implemented NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// this code add a "read" class to each &lt;p&gt; markup</span>
<span class="hljs-comment">// contained in each &lt;article&gt; markup</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="maps"><a href="#maps" class="phenomic-HeadingAnchor">#</a><em>Maps</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="sets"><a href="#sets" class="phenomic-HeadingAnchor">#</a><em>Sets</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="generators"><a href="#generators" class="phenomic-HeadingAnchor">#</a><em>Generators</em></h3>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>What about traditional object ?</p>
</blockquote>
<p>Suprisingly, objects can&#x27;t be directly browsed by this brand new loop.
Fortunately a workaround exists such as
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="in-a-nutshell"><a href="#in-a-nutshell" class="phenomic-HeadingAnchor">#</a>In a nutshell</h2>
<p><code>for..of</code> comes to address <code>for..in</code> loop gaps and allow
a simplified iteration over <em>iterable objects</em> such as:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">String</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Maps &amp; WeakMaps</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">Generators</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a></li>
</ul>
<p>Furthermore, <code>for..of</code> as of now resolve pitfalls such as unpredictable iteration order or
automated coercion of index to string.</p>
<h2 id="to-go-further"><a href="#to-go-further" class="phenomic-HeadingAnchor">#</a>To go further</h2>
<p><code>for..of</code> loop is another added arrow to ES6 bow that
allows to run through, in a native way, the brand new <em>iterable objects</em> of the language.</p>
<p>For information about this feature :</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">MDN Documentation</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">The post of Jason Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">The post of Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">ECMA-262 Specification</a></li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : la boucle for..of]]></title><description><![CDATA[<h2 id="introduction"><a href="#introduction" class="phenomic-HeadingAnchor">#</a>Introduction</h2>
<p>Avec l&#x27;arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de
s&#x27;enrichir de
nouvelles façons de parcourir ces derniers. Dans l&#x27;unique souci de maintenir la
rétro-compatibilité
avec l&#x27;existant, l&#x27;ES6 se devait de garder la boucle <code>for..in</code> intacte.</p>
<blockquote>
<p>Mais alors, comment créer une variante de cette même boucle avec des capacités
améliorées ?</p>
</blockquote>
<p>La solution est simple : &quot;Bienvenue au mot-clé <code>of</code> !&quot;</p>
<p>Mais avant d&#x27;en dire plus, et pour comprendre l&#x27;utilité de ce nouveau mot-clé,
revoyons un peu l&#x27;existant.</p>
<h2 id="le-bon-vieux-forin"><a href="#le-bon-vieux-forin" class="phenomic-HeadingAnchor">#</a>Le bon vieux <code>for..in</code></h2>
<p>Tout <em>JavaScript enthusiast</em> qui se respecte connaissait déjà la fameuse boucle
<code>for..in</code>
dont l&#x27;utilité première est d&#x27;itérer sur les différentes clés d&#x27;un objet ou d&#x27;un
tableau.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>La boucle <code>for..in</code>, malgré son apparente simplicité d&#x27;utilisation, cache
certains pièges :</p>
<ul>
<li>
<p>Lors de l&#x27;itération sur un tableau la valeur de l&#x27;index est convertie en
chaîne
de caractères : &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, etc. Cela peut potentiellement poser problème
lors de
l&#x27;utilisation de l&#x27;index dans des opérations de calcul.</p>
</li>
<li>
<p>La boucle itère sur l&#x27;ensemble des clés du tableau, mais aussi sur chacune de
ses propriétés.</p>
<pre><code>&#x60;&#x60;&#x60;js
const arr = [&#x27;foo&#x27;, &#x27;bar&#x27;];
arr.oups = &#x27;baz&#x27;;

for ( const key in arr ) {
  console.log( key + &#x27;-&gt;&#x27; + arr[key] ); // &#x27;0-&gt;foo&#x27;, &#x27;1-&gt;bar&#x27;, &#x27;oups-&gt;baz&#x27;
}
&#x60;&#x60;&#x60;
</code></pre>
</li>
<li>
<p>L&#x27;ordre d&#x27;itération sur l&#x27;ensemble des clés d&#x27;un objet peut varier selon
l&#x27;environnement d&#x27;éxecution du code.</p>
</li>
</ul>
<h2 id="la-methode-alternative-foreach"><a href="#la-methode-alternative-foreach" class="phenomic-HeadingAnchor">#</a>La methode alternative <code>.forEach()</code></h2>
<p>La boucle
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach"><code>Array.prototype.forEach()</code></a>
permet une itération plus sécurisée, mais présente certains autres inconvénients
tels que :</p>
<ul>
<li>L&#x27;impossibilité d&#x27;interrompre la boucle avec les instructions traditionnelles
<code>break;</code> et <code>return;</code></li>
<li>Il s&#x27;agit d&#x27;une méthode réservée aux tableaux.</li>
</ul>
<h2 id="forof-à-la-rescousse"><a href="#forof-%C3%A0-la-rescousse" class="phenomic-HeadingAnchor">#</a><code>for..of</code> à la rescousse</h2>
<p>Le consortium ECMA a donc décidé de procéder à la création d&#x27;une nouvelle
version améliorée
de la boucle <code>for..in</code>. Ainsi naquit la boucle <code>for..of</code> qui coexistera
désormais avec la précédente,
permettant de maintenir la rétro-compatibilité avec les versions antérieures de
la norme.</p>
<p>Le principe est le même : parcourir n&#x27;importe quel type <em>d&#x27;objet itérable</em>.</p>
<p>Dans sa forme la plus simple, la boucle <code>for..of</code> permet donc d&#x27;itérer sur
l&#x27;ensemble des valeurs des clés d&#x27;un tableau.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>La boucle <code>for..of</code> peut aussi itérer sur des types plus complexes. Examinons
cela de plus près.</p>
<h3 id="les-strings"><a href="#les-strings" class="phenomic-HeadingAnchor">#</a>Les <em>Strings</em></h3>
<p>Dans ce cas, chaque caractère est traité comme une entité Unicode.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="les-nodelist"><a href="#les-nodelist" class="phenomic-HeadingAnchor">#</a>Les <em>NodeList</em></h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// Note: cela ne fonctionnera que sur les environnements</span>
<span class="hljs-comment">// implémentant NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// ce code ajoute une class "read" à toutes les balises &lt;p&gt;</span>
<span class="hljs-comment">// contenues dans la(les) balises &lt;article&gt;</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="les-maps"><a href="#les-maps" class="phenomic-HeadingAnchor">#</a>Les <em>Maps</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="les-sets"><a href="#les-sets" class="phenomic-HeadingAnchor">#</a>Les <em>Sets</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="les-generators"><a href="#les-generators" class="phenomic-HeadingAnchor">#</a>Les <em>Generators</em></h3>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>Et les objets traditionnels dans tout ça ?</p>
</blockquote>
<p>Étonnamment, les objets ne peuvent pas être parcourus avec cette nouvelle
boucle sauf s&#x27;ils définissent le symbole <code>Symbol.iterator</code>. Heureusement,
il existe une solution de contournement par l&#x27;utilisation de
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a>
ou encore
d&#x27;<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/values"><code>Object.values()</code></a>
et
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/entries"><code>Object.entries()</code></a>
(ajouts ECMAScript7).</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>Exemple définissant un itérateur :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> iterableObj = {
  *[<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span>* <span class="hljs-built_in">Object</span>.entries(obj);
  }
};

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [key, val] <span class="hljs-keyword">of</span> iterableObj ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + val); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="en-résumé"><a href="#en-r%C3%A9sum%C3%A9" class="phenomic-HeadingAnchor">#</a>En résumé</h2>
<p><code>for..of</code> vient compléter les lacunes de <code>for..in</code> et permet
une itération simplifiée sur les <em>objets itérables</em> tels que :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String">String</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/">Maps &amp; WeakMaps</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/sets-weaksets/">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*">Generators</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments">arguments</a></li>
</ul>
<p>De plus, <code>for..of</code> résout à présent les pièges tels que l&#x27;ordre d&#x27;itération non
constant ou la coercion
automatique des index en chaîne de caractères.</p>
<h2 id="pour-aller-plus-loin"><a href="#pour-aller-plus-loin" class="phenomic-HeadingAnchor">#</a>Pour aller plus loin</h2>
<p>La boucle <code>for..of</code> est donc une corde de plus à l&#x27;arc de l&#x27;ES6 qui
permet de parcourir, de manière native, les tout nouveaux <em>objets itérables</em> du
langage.</p>
<p>Pour en savoir plus sur ses spécificités :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of">Documentation
MDN</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">Le post de Jason
Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">Le post de Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">Specification
ECMA-262</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Arrow functions]]></title><description><![CDATA[<p>ES2015 brings us some new syntax sugar that will likely make you stop using
<code>Function.prototype.bind()</code>.</p>
<p>Arrow functions are just a function shorthand using the <code>=&gt;</code> syntax.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Arrow functions are syntactically similar to the related feature that exists in
other languages like CoffeeScript, Java (8+), C#…</p>
<p>They support both expression and statement bodies.
In our example above, we have seen a classic statement.
But for simple function, we can use an simple expression, to make things shorter.
That means that the previous example can be also written like this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Note that when you have only one argument, you can omit parenthesis around it.
So we can also wrote the example like this</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>And you can also wrap the body in parenthesis if you want to make a multiline expression</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// that can be multilines, you can imagine some JSX here ;)</span>
)</code></pre>
<p>So this examples are all the same :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>In practice you will use this small functions in method like Array
reduce/filter/map etc.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="arrow-functions-dont-have-a-this"><a href="#arrow-functions-dont-have-a-this" class="phenomic-HeadingAnchor">#</a>Arrow functions don’t have a <code>this</code></h2>
<p>Yes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.
So that means the <code>this</code> you might use use in the body of an arrow function refer to the parent scope:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Someone = {
  name: “MoOx”,
  friends: [], <span class="hljs-comment">// he got no friends atm :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` is not the function of the forEach !</span>
    )
  }
}</code></pre>
<p>By reading this code, you might understand that you are likely to stop using
<code>bind()</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> “react”
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stuff</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  <span class="hljs-comment">// old way</span>
  onClick(e) {
    <span class="hljs-keyword">this</span>.setState({ omg: <span class="hljs-literal">false</span> })
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        { /* old way */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.onClick.bind</span>(<span class="hljs-attr">this</span>) }&gt;</span>
          Old binded call
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* LOOK MA', NO BIND ! */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.onClick(e) }&gt;
          I don’t need `bind` anymore !
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* Simpler way */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.setState({ omg: true }) }&gt;
          Hell yeah
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}</code></pre>
<h2 id="note-about-expression-body-and-object"><a href="#note-about-expression-body-and-object" class="phenomic-HeadingAnchor">#</a>Note about expression body and Object</h2>
<p>If you want to return an object you might be surprised to get <code>undefined</code>
with this code:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}</code></pre>
<p>Indeed the above snippet could be translated into ES5 this way:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> aFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
  key:         <span class="hljs-comment">// Defines a label named `key`</span>
    obj.value  <span class="hljs-comment">// Gets `obj.value`</span>
               <span class="hljs-comment">// Implicit returns `undefined`</span>
}</code></pre>
<p>Keep in mind that in this context, a brace is to start a statement body, not an
object.
So you will need this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>But wait, there is a trick: a stupid couple of parenthesis.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works!</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Take a look to the
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">compatibility table</a>.
You will see that arrow functions are already supported by most browsers but you
might need <a href="http://babeljs.io">Babel</a> to use it today.</p>
<p>You will probably use this more and more.
Even if <code>function</code> keyword is not dead, arrow functions <code>=&gt;</code> are probably
going to be a thing !</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les fonctions fléchées]]></title><description><![CDATA[<p>ES2015 nous apporte encore du sucre syntaxique qui risque très probablement de
vous faire oublier <code>Function.prototype.bind()</code>.</p>
<p>Les fonctions fléchées offrent une syntaxe raccourcie des fonctions en utilisant
la syntaxe <code>=&gt;</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Les fonctions fléchées sont syntaxiquement similaires à ce qu&#x27;on trouve déjà dans
d&#x27;autres langages comme CoffeeScript, Java (8+), C#…</p>
<p>Elles supportent les expressions ou les blocs en tant que corps de fonction.
Dans notre exemple précédent, nous avons utilisé un corps classique.
Pour de simples fonctions, nous pouvons utiliser des expressions, le but étant
d&#x27;avoir quelque chose de concis.
Notre exemple précédent peut ainsi s&#x27;écrire de la sorte :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Notez que lorsque l&#x27;on a qu&#x27;un argument dans notre fonction, on peut omettre les
parenthèses. Notre exemple peut donc aussi s&#x27;écrire ainsi :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Si notre expression mérite d&#x27;être sur plusieurs lignes, on peut aussi utiliser des
parenthèses :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// Ici vous pouvez faire du multi lignes tranquille, on peut imaginer du JSX</span>
)</code></pre>
<p>Les exemples suivants sont donc tous les mêmes :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>Dans la pratique, vous utiliserez souvent cette syntaxe pour des petites méthodes
comme par exemple lors de l&#x27;utilisation des fonctions de tableau
reduce/filter/map, etc.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="les-fonctions-fléchées-nont-pas-de-this"><a href="#les-fonctions-fl%C3%A9ch%C3%A9es-nont-pas-de-this" class="phenomic-HeadingAnchor">#</a>Les fonctions fléchées n&#x27;ont pas de <code>this</code></h2>
<p>Oui, vous avez bien lu : à l&#x27;inverse des fonctions normales, les fonctions
fléchées partagent le même <code>this</code> lexical que leur scope parent.
Du coup, le <code>this</code> que vous pourrez utiliser dans votre corps de fonction
fléchée est celui du code parent :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Someone = {
  name: “MoOx”,
  friends: [], <span class="hljs-comment">// Malheureusement, il n'a pas d'amis :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` ne réfère pas à la fonction fléchée du forEach !</span>
    )
  }
}</code></pre>
<p>En lisant ce code, vous avez peut être compris qu&#x27;il peut être possible de ne
plus avoir besoin du <code>bind()</code> aussi souvent que ça pouvait être le cas :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> “react”
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stuff</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  <span class="hljs-comment">// à l'ancienne</span>
  onClick(e) {
    <span class="hljs-keyword">this</span>.setState({ omg: <span class="hljs-literal">false</span> })
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        { /* à l'ancienne */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.onClick.bind</span>(<span class="hljs-attr">this</span>) }&gt;</span>
          Old binded call
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* REGARDE MAMAN, JE BIND RIEN */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.onClick(e) }&gt;
          I don’t need `bind` anymore !
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* Encore plus simplement */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.setState({ omg: true }) }&gt;
          Hell yeah
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}</code></pre>
<h2 id="note-sur-les-expressions-et-les-objets"><a href="#note-sur-les-expressions-et-les-objets" class="phenomic-HeadingAnchor">#</a>Note sur les expressions et les objets</h2>
<p>Si vous voulez retourner un objet, vous serez surement supris de ne pas obtenir
le résultat attendu avec ce code :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}
<span class="hljs-built_in">console</span>.log(aFn()) <span class="hljs-comment">// undefined</span></code></pre>
<p>En effet, l&#x27;exemple ci-dessus pourrait être traduit en ES5 de la manière suivante :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> aFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
  key:         <span class="hljs-comment">// Defines a label named `key`</span>
    obj.value  <span class="hljs-comment">// Gets `obj.value`</span>
               <span class="hljs-comment">// Implicit returns `undefined`</span>
}</code></pre>
<p>Gardez en tête que dans ce contexte, une accolade ouvre un corps de fonction,
pas un objet.
Vous devrez donc faire comme ceci :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>Mais attendez, avec une simple astuce, on s&#x27;en sort avec un couple de
parenthèses :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works !</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Regardez
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">la table de compatibilité</a>.
C&#x27;est plutôt bien supporté par la plupart des navigateurs, mais vous risquez
sûrement d&#x27;avoir à utiliser <a href="http://babeljs.io">Babel</a> afin d&#x27;être tranquille.</p>
<p>Vous verrez que vous utiliserez les fonctions fléchées de plus en plus.
Même si le mot clé <code>function</code> n&#x27;est pas mort, les fonctions fléchées ont un
avenir certain !</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES2016 (?): fonctions asynchrones (async/await)]]></title><description><![CDATA[<p>Aujourd&#x27;hui, une fonctionnalité peut-être abusivement taggée &quot;ES6&quot; puisqu&#x27;elle ne
fait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).
La <a href="https://tc39.github.io/ecmascript-asyncawait/">spécification</a> est encore au
stade 3 (candidate) à l&#x27;heure de cet article. Mais il ne fait plus aucun doute
qu&#x27;elle (ou une variante) fera partie de la spécification ES2016.</p>
<h2 id="fonctions-asynchrones"><a href="#fonctions-asynchrones" class="phenomic-HeadingAnchor">#</a>Fonctions asynchrones</h2>
<p>Pour les traitements asynchrones, vous connaissez déjà
<a href="/fr/articles/js/es2015/promises/">les promesses</a> qui ont
évidemment remplacé les callbacks dans votre code. Si vous n&#x27;avez pas déjà fait
la bascule vers les promesses (ne serait-ce que pour la propagation d&#x27;erreur),
<a href="/fr/articles/js/es2015/generators/">les générateurs</a> ont
dû finir de vous convaincre grâce aux <a href="/fr/articles/js/es2015/generators/#use-case-co-routines">coroutines</a>.</p>
<p>Nous allons voir aujourd&#x27;hui une nouvelle manière de traiter les fonctions
asynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d&#x27;elles.</p>
<h2 id="exemple-de-traitement-asynchrone-promise"><a href="#exemple-de-traitement-asynchrone-promise" class="phenomic-HeadingAnchor">#</a>Exemple de traitement asynchrone : Promise</h2>
<p>Partons du programme suivant exécuté le
6 décembre dernier dont l&#x27;API est basée sur les promesses :</p>
<ul>
<li>Il récupère tous les utilisateurs prénommés Nicolas</li>
<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> usersP = getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-comment">// On récupère le champ "email" de tous les utilisateurs</span>
  <span class="hljs-keyword">const</span> emailsP = usersP.then((users) =&gt; users.map(u =&gt; u.email))
  <span class="hljs-comment">// Pour chaque email…</span>
  <span class="hljs-keyword">const</span> sentP = emailsP.then((emails) =&gt; emails.map((email) =&gt; {
    <span class="hljs-comment">// … on envoie un mail</span>
    <span class="hljs-keyword">return</span> sendMail(email, <span class="hljs-string">'Bonne fête'</span>)
  }))
  <span class="hljs-comment">// On attend que tous les envois soient résolus</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
  .then(() =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>))
  .catch(() =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>))</code></pre>
<h2 id="nouveaux-mot-clés-async-et-await"><a href="#nouveaux-mot-cl%C3%A9s-async-et-await" class="phenomic-HeadingAnchor">#</a>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>
<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// …</span>
}</code></pre>
<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le
mot-clé <code>await</code> devient disponible. Lorsqu&#x27;il est utilisé en préfixe d&#x27;une
promesse, l&#x27;évaluation de l&#x27;expression est &quot;mise en pause&quot; jusqu&#x27;à la résolution
(ou le rejet) de la promesse :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> aPromise
  <span class="hljs-comment">// on n'arrivera à cette ligne que lorsque "aPromise" sera résolue</span>
}</code></pre>
<p>Évidemment, l&#x27;expression a alors pour valeur celle de résolution de la
promesse, et en cas d&#x27;erreur l&#x27;expression va lever (<code>throw</code>) une erreur :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> aPromise
    <span class="hljs-comment">// Ici "aPromise" est résolue avec la valeur "result"</span>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// Ici "aPromise" est rejetée avec l'erreur "err"</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> <span class="hljs-comment">// cette ligne n'est atteinte qu'après résolution/rejet</span>
}</code></pre>
<p>Concrètement, si vous vous souvenez de l&#x27;article sur les générateurs et de la
partie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et
<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>
<h2 id="notre-premier-exemple-avec-les-fonctions-asynchrones"><a href="#notre-premier-exemple-avec-les-fonctions-asynchrones" class="phenomic-HeadingAnchor">#</a>Notre premier exemple, avec les fonctions asynchrones</h2>
<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-keyword">const</span> emails = users.map(u =&gt; u.email)
  <span class="hljs-keyword">const</span> sentP = emails.map((email) =&gt; sendMail(email, <span class="hljs-string">'Bonne fête'</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

<span class="hljs-comment">// Attention, on ne peut pas utiliser "await" hors d'une fonction "async"</span>
<span class="hljs-comment">// il faut donc "wrapper" notre code autour d'une fonction asynchrone</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>)
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>)
  }
}

main()</code></pre>
<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus
habituel.</p>
<h2 id="attention-au-piège-de-lexécution-en-série"><a href="#attention-au-pi%C3%A8ge-de-lex%C3%A9cution-en-s%C3%A9rie" class="phenomic-HeadingAnchor">#</a>Attention au piège de l&#x27;exécution en série !</h2>
<p>Prenons l&#x27;exemple de requêtes qu&#x27;on exécute en concurrence avant d&#x27;utiliser
leurs résultats :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD</span>
<span class="hljs-keyword">const</span> resultP = <span class="hljs-built_in">Promise</span>.all([xP, yP]).then(sum)</code></pre>
<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs
retours attendus avant de passer à la suite.</p>
<p>Si on le traduit bêtement ainsi, on perd l&#x27;aspect concurrentiel :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> getX() <span class="hljs-comment">// Requête Ajax…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> getY() <span class="hljs-comment">// Requête BDD…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])</code></pre>
<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l&#x27;action</strong> et le
moment où l&#x27;on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières
de résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax démarrée…</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD démarrée…</span>

<span class="hljs-comment">// Version 1 :</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> xP <span class="hljs-comment">// …requête Ajax terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> yP <span class="hljs-comment">// …requête BDD terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])

<span class="hljs-comment">// Version 2 avec un tableau :</span>
<span class="hljs-keyword">const</span> vars = [<span class="hljs-keyword">await</span> xP, <span class="hljs-keyword">await</span> yP]
<span class="hljs-keyword">const</span> result = sum(vars)

<span class="hljs-comment">// Version 3 avec Promise.all :</span>
<span class="hljs-keyword">const</span> vars = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([xP, yP])
<span class="hljs-keyword">const</span> result = sum(vars)</code></pre>
<h2 id="et-aujourdhui"><a href="#et-aujourdhui" class="phenomic-HeadingAnchor">#</a>Et aujourd&#x27;hui ?</h2>
<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un
code basé sur les générateurs : il vous suffira d&#x27;ajouter les plugins Babel
<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à
inclure <code>babel-polyfill</code> en fichier d&#x27;entrée).</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Grâce aux fonctions asynchrones, la refactorisation d&#x27;un code bloquant vers un
code non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le
processus mais on n&#x27;était pas débarassé des callbacks. Là, à deux mot-clés près,
c&#x27;est exactement la même chose !</p>
<p>D&#x27;un certain côté, c&#x27;est un retour en arrière : l&#x27;asynchrone mène aux promesses,
qui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il
s&#x27;agira de trouver le bon équilibre, je ne suis pas convaincu d&#x27;abandonner mes
<code>.then</code> tout de suite, mais il est certain que c&#x27;est une véritable avancée
pour ce langage : la courbe d&#x27;apprentissage des traitements asynchrones va être
drastiquement aplanie ;)</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2016/async-await/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2016/async-await/</guid><pubDate>Mon, 14 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les nouvelles méthodes d'Array]]></title><description><![CDATA[<p><del>ES6</del>  ES2015 enrichit les objets de la bibiliothèque standard de nouvelles fonctionnalités.
Voici les nouveautés que l&#x27;on va trouver dans <code>Array</code>.</p>
<h2 id="arrayfrom"><a href="#arrayfrom" class="phenomic-HeadingAnchor">#</a>Array.from()</h2>
<p>Parmi les nouvelles méthodes ajoutées à Array, <code>Array.from()</code> est peut-être celle que vous allez utiliser le plus souvent. Elle va nous permettre de créer un tableau à partir d&#x27;un itérable ou d&#x27;un objet qui ressemble à un tableau comme une NodeList, ou encore <code>arguments</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> nodes = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySeletorAll(<span class="hljs-string">'div'</span>))
nodes.forEach(node =&gt; <span class="hljs-built_in">console</span>.log(node))</code></pre>
<h2 id="arrayof"><a href="#arrayof" class="phenomic-HeadingAnchor">#</a>Array.of()</h2>
<p>Cette méthode va permettre de créer un tableau à partir des arguments reçus.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.of(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)
<span class="hljs-built_in">console</span>.log(arr.join(<span class="hljs-string">" "</span>)) <span class="hljs-comment">// "hello world"</span></code></pre>
<h2 id="arrayprototypekeys--arrayprototypeentries"><a href="#arrayprototypekeys--arrayprototypeentries" class="phenomic-HeadingAnchor">#</a>Array.prototype.keys() &amp; Array.prototype.entries()</h2>
<p>On retrouve aussi ces méthodes sur d&#x27;autres itérables comme Map ou Set.
<code>Array.prototype.keys()</code> va renvoyer un nouveau tableau dont les valeurs seront les clefs du tableau passées en paramètre :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr =  [...Array(<span class="hljs-number">3</span>).keys()]
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [0,1,2]</span></code></pre>
<p><code>Array.prototype.entries()</code> quant à lui va renvoyer un tableau composé des paires clé/valeur :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>]
<span class="hljs-built_in">console</span>.log(arr.entries()) <span class="hljs-comment">// [[0, "hello"], [1, "world"]]</span></code></pre>
<h2 id="arrayprototypefind"><a href="#arrayprototypefind" class="phenomic-HeadingAnchor">#</a>Array.prototype.find()</h2>
<p>Cette méthode va permettre de renvoyer une valeur contenue dans le tableau si celle-ci vérifie
la condition définie par la fonction de prédicat passée en paramètre. On retrouve le même principe qu&#x27;avec <code>filter</code>, <code>some</code> et <code>every</code>. Si aucune valeur ne
valide la fonction de prédicat, alors la méthode renverra <code>undefined</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [{id:<span class="hljs-number">1</span>, label:<span class="hljs-string">"hello"</span>}, {id:<span class="hljs-number">2</span>, name: <span class="hljs-string">"world"</span>}]
<span class="hljs-keyword">const</span> found = arr.find(item =&gt; item.id === <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> notfound = arr.find(item =&gt; item.id === <span class="hljs-number">3</span>)
<span class="hljs-built_in">console</span>.log(found, notfound) <span class="hljs-comment">// {id:2, name: "worl"}, undefined</span></code></pre>
<p>À noter qu&#x27;il existe aussi <code>Array.prototype.findIndex()</code> qui renverra non pas l&#x27;objet, mais l&#x27;index de l&#x27;objet qui validera la fonction de prédicat.</p>
<h2 id="arrayprototypefill"><a href="#arrayprototypefill" class="phenomic-HeadingAnchor">#</a>Array.prototype.fill()</h2>
<p>Cette méthode va permettre de remplir un tableau avec une valeur passée en paramètre. Il est toutefois possible de définir un index de début et un index de fin (comme avec slice par exemple) si l&#x27;on ne souhaite remplacer qu&#x27;une partie du tableau.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>).fill(<span class="hljs-number">1</span>)
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [1,1,1]</span></code></pre>
<h2 id="arrayprototypecopywithin"><a href="#arrayprototypecopywithin" class="phenomic-HeadingAnchor">#</a>Array.prototype.copyWithin()</h2>
<p>Cette méthode va permettre de renvoyer un nouveau tableau en remplaçant une partie du tableau par une séquence de ce dernier. Pour cela, on va indiquer à partir de quel index on souhaite démarrer la copie de la séquence, ainsi que l&#x27;index de début et de fin de la séquence que l&#x27;on souhaite voir répétée.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>,<span class="hljs-string">"alice"</span>, <span class="hljs-string">"my"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"is"</span> <span class="hljs-string">"bob"</span>]
<span class="hljs-built_in">console</span>.log(arr.copyWithin(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)]) <span class="hljs-comment">//  "hello","bob", "my", "name", "is" "bob"]</span></code></pre>
<p>Certaines méthodes ne paraissent pas forcément super utiles alors n&#x27;hésitez à utiliser les commentaires pour partager des exemples d&#x27;utilisation plus intéressants 😛</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</guid><pubDate>Sun, 13 Dec 2015 00:00:00 GMT</pubDate></item></channel></rss>