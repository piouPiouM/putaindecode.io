{"head":{"layout":"Post","comments":true,"date":"2016-06-16","title":"Pourquoi j'ai arrêté d'utiliser CSS","tags":["css","style-inline","javascript"],"authors":["bloodyowl"],"description":"CSS est un langage horriblement dangereux, parce qu'il mêle des concepts complètement pétés et une folle capacité à faire confondre facilité…"},"body":"<p>CSS est un langage horriblement dangereux, parce qu&#x27;il mêle des concepts complètement pétés et une folle capacité à faire confondre facilité et simplicité aux gens qui l&#x27;utilisent.</p>\n<h2 id=\"quest-ce-qui-ne-va-pas-\"><a href=\"#quest-ce-qui-ne-va-pas-\" class=\"phenomic-HeadingAnchor\">#</a>Qu&#x27;est-ce qui ne va pas ?</h2>\n<p>À l&#x27;origine, CSS a été conçu pour styler des documents, pas des applications. Du coup lorsqu&#x27;on doit <em>scale</em>, c&#x27;est rapidement douloureux.</p>\n<h3 id=\"les-sélecteurs\"><a href=\"#les-s%C3%A9lecteurs\" class=\"phenomic-HeadingAnchor\">#</a>Les sélecteurs</h3>\n<p>Les sélecteurs sont des <strong>variables globales mutables</strong>. Lorsque vous faites :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.selector</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n}</code></pre>\n<p>C&#x27;est comme si en JavaScript vous faisiez :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.selector = (<span class=\"hljs-built_in\">window</span>.selector || []).concat({\n  fontSize: <span class=\"hljs-string\">\"1rem\"</span>,\n})</code></pre>\n<p>Ça veut dire que :</p>\n<ul>\n<li>La définition d&#x27;un style associé à un sélecteur peut être redéfinie ailleurs</li>\n<li>Si on associe plusieurs styles à un sélecteur, les derniers définis dans le CSS auront toujours la priorité</li>\n<li>Quelqu&#x27;un peut péter les styles d&#x27;un composant pour peu qu&#x27;il ne sache pas qu&#x27;un sélecteur est utilisé ailleurs</li>\n</ul>\n<h3 id=\"la-spécificité\"><a href=\"#la-sp%C3%A9cificit%C3%A9\" class=\"phenomic-HeadingAnchor\">#</a>La spécificité</h3>\n<p>Alors ça, c&#x27;est particulièrement drôle : la spécificité d&#x27;un sélecteur va définir la priorité d&#x27;application d&#x27;un style.</p>\n<table>\n<thead>\n<tr>\n<th>Sélecteur</th>\n<th>Spécificité</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*</code></td>\n<td>0,0,0,0</td>\n</tr>\n<tr>\n<td><code>li</code></td>\n<td>0,0,0,1</td>\n</tr>\n<tr>\n<td><code>li:first-line</code></td>\n<td>0,0,0,2</td>\n</tr>\n<tr>\n<td><code>ul li</code></td>\n<td>0,0,0,2</td>\n</tr>\n<tr>\n<td><code>ul ol+li</code></td>\n<td>0,0,0,3</td>\n</tr>\n<tr>\n<td><code>h1 + *[rel=up]</code></td>\n<td>0,0,1,1</td>\n</tr>\n<tr>\n<td><code>ul ol li.red</code></td>\n<td>0,0,1,3</td>\n</tr>\n<tr>\n<td><code>li.red.level</code></td>\n<td>0,0,2,1</td>\n</tr>\n<tr>\n<td><code>#x34y</code></td>\n<td>0,1,0,0</td>\n</tr>\n</tbody>\n</table>\n<p>Si le style est défini dans l&#x27;attribut <code>style</code>, la spécificité est de 1,0,0,0. Si une valeur associée à une propriété est suffixée d&#x27;un <code>!important</code>, elle prend quoi qu&#x27;il arrive l&#x27;ascendance.</p>\n<p>Si on résume, on nage en plein délire, la priorité se définit dans l&#x27;ordre par : la présence de <code>!important</code>, la façon de définir le style, la spécificité du sélecteur utilisé puis par l&#x27;ordre de définition dans l&#x27;ensemble des CSS de la page. Évidemment, à l&#x27;époque où on n&#x27;avait qu&#x27;une pauvre petite feuille de style pour l&#x27;ensemble de son site, ça marchait ; plus maintenant.</p>\n<h3 id=\"les-régressions\"><a href=\"#les-r%C3%A9gressions\" class=\"phenomic-HeadingAnchor\">#</a>Les régressions</h3>\n<p>Prenons un exemple tout bête :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.item</span> {\n  <span class=\"hljs-attribute\">display</span>: block;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n  <span class=\"hljs-attribute\">color</span>: blue;\n}\n\n<span class=\"hljs-selector-class\">.some-context</span> <span class=\"hljs-selector-class\">.item</span> {\n  <span class=\"hljs-attribute\">display</span>: inline-block;\n  <span class=\"hljs-attribute\">color</span>: red;\n}</code></pre>\n<p>Quelqu&#x27;un de la team modifie <code>.item</code> :</p>\n<pre><code class=\"hljs language-diff\"> .item {\n   display: block;\n   font-size: 1rem;\n   color: blue;\n<span class=\"hljs-addition\">+  border: 1px solid red;</span>\n }\n\n .some-context .item {\n   display: inline-block;\n   color: red;\n}</code></pre>\n<p>Super, une regression dans <code>some-context</code>. Face à ça, deux possibilités :</p>\n<ul>\n<li>Vous vous foutez d&#x27;avoir des régressions qui pètent votre site</li>\n<li>À chaque changement minime du CSS vous vérifiez l&#x27;intégralité du site et testez tous les comportements dans tous les contextes.</li>\n</ul>\n<h3 id=\"le-choix-de-priorisation-des-styles\"><a href=\"#le-choix-de-priorisation-des-styles\" class=\"phenomic-HeadingAnchor\">#</a>Le choix de priorisation des styles</h3>\n<p>Ce serait pas mal de décider quel <code>className</code> est appliqué en priorité :</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"blue red\"</span>&gt;</span>text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"red blue\"</span>&gt;</span>text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>mais bien évidemment non, comme vu plus haut, c&#x27;est le foutu ordre de définition des sélecteurs qui décide. Je vous laisse imaginer le bordel si on charge les feuilles de style à la demande, selon les actions utilisateur.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.blue</span> { <span class=\"hljs-attribute\">color</span>: blue; }\n<span class=\"hljs-selector-class\">.red</span> { <span class=\"hljs-attribute\">color</span>: red; }</code></pre>\n<p>C&#x27;est pire si vous utilisez un préprocesseur tel que Sass et LESS. Lorsque vous faites un :</p>\n<pre><code class=\"hljs language-css\">.blue {\n  color: blue;\n}\n\n.red {\n  color: red;\n}\n\n.my-selector {\n  @extend .red;\n  @extend .blue;\n}</code></pre>\n<p>Vous imaginez que <code>.blue</code> étant appliqué après dans <code>.my-selector</code>, il va prendre la priorité. EH BAH NON, c&#x27;est <code>.red</code>, parce que sa déclaration est située après <code>.blue</code>.</p>\n<p>Si ce constat peut aussi permettre à ceux et celles qui utilisent des CSS atomiques d&#x27;arrêter immédiatement :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.relative</span> { <span class=\"hljs-attribute\">position</span>: relative; }\n<span class=\"hljs-selector-class\">.absolute</span> { <span class=\"hljs-attribute\">position</span>: absolute; }\n<span class=\"hljs-selector-class\">.static</span> { <span class=\"hljs-attribute\">position</span>: static; }</code></pre>\n<p>Dans le cas précédent, si vous ajoutez une classe <code>relative</code> à un élement ayant déjà la classe <code>static</code>, ça ne changera rien du tout, parce que <code>.static</code> est défini après <code>.relative</code>. Génial, non ?</p>\n<h3 id=\"le-futur-de-css\"><a href=\"#le-futur-de-css\" class=\"phenomic-HeadingAnchor\">#</a>Le futur de CSS</h3>\n<p>Les variables sont une feature qui a été très demandée à CSS. Mais cette feature va débarquer avec son lot de souci :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">:root</span> {\n  <span class=\"hljs-attribute\">--mainColor</span>: blue;\n}\n\n<span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--mainColor);\n}</code></pre>\n<p>C&#x27;est super, mais si quelqu&#x27;un vient ajouter :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">:root</span> {\n  <span class=\"hljs-attribute\">--mainColor</span>: red;\n}</code></pre>\n<p>quelque part, il y a deux cas :</p>\n<ul>\n<li>soit c&#x27;est chargé avant, et ça ne fait rien</li>\n<li>soit c&#x27;est chargé après, et ça override toutes les propriétés utilisant <code>--mainColor</code>. On est bien contents.</li>\n</ul>\n<h2 id=\"vous-ne-pouvez-pas-vous-permettre-de-laisser-tomber-css-\"><a href=\"#vous-ne-pouvez-pas-vous-permettre-de-laisser-tomber-css-\" class=\"phenomic-HeadingAnchor\">#</a>Vous ne pouvez pas vous permettre de laisser tomber CSS ?</h2>\n<p>Dans ce cas, forcez vous à utiliser la <a href=\"/fr/articles/css/bem/\">méthodologie BEM</a>. Ça ne réglera pas tout, mais au moins cela vous permettra d&#x27;éviter un maximum de conneries en vous forçant à découper en composants isolés, et à mieux maîtriser la priorisation, puisque le scope auquel vous devrez y veiller sera considérablement réduit :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* Header.css */</span>\n<span class=\"hljs-selector-class\">.Header</span> {}\n\n  <span class=\"hljs-selector-class\">.Header-nav</span> {}\n\n<span class=\"hljs-comment\">/* Nav.css */</span>\n<span class=\"hljs-selector-class\">.Nav</span> {}\n\n  <span class=\"hljs-selector-class\">.Nav-item</span> {}\n\n    <span class=\"hljs-selector-class\">.Nav-item--active</span> {}</code></pre>\n<p>C&#x27;est quand même plus pratique à comprendre, non ?</p>\n<p>Encore mieux, si vous avez du tooling à la webpack, vous pouvez utiliser les <a href=\"/fr/articles/css/modules/\">CSS modules</a>, qui limiteront de même le scope d&#x27;application de vos feuilles de style.</p>\n<h2 id=\"vous-pouvez-vous-permettre-de-laisser-tomber-css-\"><a href=\"#vous-pouvez-vous-permettre-de-laisser-tomber-css-\" class=\"phenomic-HeadingAnchor\">#</a>Vous pouvez vous permettre de laisser tomber CSS ?</h2>\n<p>JavaScript vous permet déjà de bénéficier d&#x27;un système de modules, de variables, de conditions, de fonctions réutilisables, et tout ça sans hack. En plus de ça, vous maitrisez la priorisation, parce c&#x27;est que c&#x27;est vous qui décidez ce qui s&#x27;applique :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  render() {\n    <span class=\"hljs-keyword\">const</span> { active, disabled } = <span class=\"hljs-keyword\">this</span>.props\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n          <span class=\"hljs-attr\">...styles.myComponent</span>,\n          <span class=\"hljs-attr\">...active</span> ? <span class=\"hljs-attr\">styles.active</span> <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>,\n          <span class=\"hljs-attr\">...disabled</span> &amp;&amp; !<span class=\"hljs-attr\">active</span> ? <span class=\"hljs-attr\">styles.disabled</span> <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>,\n        }}\n      &gt;</span>\n        tadaa\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    )\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> styles = {\n  myComponent: {\n    fontSize: <span class=\"hljs-number\">18</span>,\n  },\n  active: {\n    textDecoration: <span class=\"hljs-string\">\"underline\"</span>,\n  },\n  disabled: {\n    opacity: <span class=\"hljs-number\">0.5</span>,\n  },\n}</code></pre>\n<p>Par ailleurs, avec certaines bibliothèques permettant naturellement l&#x27;usage d&#x27;inline-styles (comme React), cela vous donne la possibilité d&#x27;avoir le style et le markup dans le même fichier, sans avoir besoin de naviguer entre les onglets de votre éditeur (vous pouvez cependant séparer en plusieurs fichiers si ça vous fait plaisir).</p>\n<p>En résumé, utiliser JS pour définir et appliquer les styles vous permet de prendre le contrôle sur le styling de vos composants, tout en apportant le confort d&#x27;un langage offrant naturellement de nombreux avantages. Si vous êtes bloqués avec CSS, partez sur les CSS modules ou la méthologie BEM selon vos possibilités. Le but, c&#x27;est d&#x27;éliminer les <a href=\"https://github.com/necolas/react-native-web/blob/master/docs/guides/style.md\">7 maux de CSS</a>.</p>\n<p>Bisous bisous.</p>\n","rawBody":"\nCSS est un langage horriblement dangereux, parce qu'il mêle des concepts complètement pétés et une folle capacité à faire confondre facilité et simplicité aux gens qui l'utilisent.\n\n## Qu'est-ce qui ne va pas ?\n\nÀ l'origine, CSS a été conçu pour styler des documents, pas des applications. Du coup lorsqu'on doit *scale*, c'est rapidement douloureux.\n\n### Les sélecteurs\n\nLes sélecteurs sont des **variables globales mutables**. Lorsque vous faites :\n\n```css\n.selector {\n  font-size: 1rem;\n}\n```\n\nC'est comme si en JavaScript vous faisiez :\n\n```javascript\nwindow.selector = (window.selector || []).concat({\n  fontSize: \"1rem\",\n})\n```\n\nÇa veut dire que :\n\n- La définition d'un style associé à un sélecteur peut être redéfinie ailleurs\n- Si on associe plusieurs styles à un sélecteur, les derniers définis dans le CSS auront toujours la priorité\n- Quelqu'un peut péter les styles d'un composant pour peu qu'il ne sache pas qu'un sélecteur est utilisé ailleurs\n\n### La spécificité\n\nAlors ça, c'est particulièrement drôle : la spécificité d'un sélecteur va définir la priorité d'application d'un style.\n\n| Sélecteur | Spécificité |\n| --- | --- |\n| `*` | 0,0,0,0 |\n| `li` | 0,0,0,1 |\n| `li:first-line` | 0,0,0,2 |\n| `ul li` | 0,0,0,2 |\n| `ul ol+li` | 0,0,0,3 |\n| `h1 + *[rel=up]` | 0,0,1,1 |\n| `ul ol li.red` | 0,0,1,3 |\n| `li.red.level` | 0,0,2,1 |\n| `#x34y` | 0,1,0,0 |\n\nSi le style est défini dans l'attribut `style`, la spécificité est de 1,0,0,0. Si une valeur associée à une propriété est suffixée d'un `!important`, elle prend quoi qu'il arrive l'ascendance.\n\nSi on résume, on nage en plein délire, la priorité se définit dans l'ordre par : la présence de `!important`, la façon de définir le style, la spécificité du sélecteur utilisé puis par l'ordre de définition dans l'ensemble des CSS de la page. Évidemment, à l'époque où on n'avait qu'une pauvre petite feuille de style pour l'ensemble de son site, ça marchait ; plus maintenant.\n\n### Les régressions\n\nPrenons un exemple tout bête :\n\n```css\n.item {\n  display: block;\n  font-size: 1rem;\n  color: blue;\n}\n\n.some-context .item {\n  display: inline-block;\n  color: red;\n}\n```\n\nQuelqu'un de la team modifie `.item` :\n\n```diff\n .item {\n   display: block;\n   font-size: 1rem;\n   color: blue;\n+  border: 1px solid red;\n }\n\n .some-context .item {\n   display: inline-block;\n   color: red;\n}\n```\n\nSuper, une regression dans `some-context`. Face à ça, deux possibilités :\n\n- Vous vous foutez d'avoir des régressions qui pètent votre site\n- À chaque changement minime du CSS vous vérifiez l'intégralité du site et testez tous les comportements dans tous les contextes.\n\n### Le choix de priorisation des styles\n\nCe serait pas mal de décider quel `className` est appliqué en priorité :\n\n```html\n<div class=\"blue red\">text</div>\n<div class=\"red blue\">text</div>\n```\n\nmais bien évidemment non, comme vu plus haut, c'est le foutu ordre de définition des sélecteurs qui décide. Je vous laisse imaginer le bordel si on charge les feuilles de style à la demande, selon les actions utilisateur.\n\n```css\n.blue { color: blue; }\n.red { color: red; }\n```\n\nC'est pire si vous utilisez un préprocesseur tel que Sass et LESS. Lorsque vous faites un :\n\n```css\n.blue {\n  color: blue;\n}\n\n.red {\n  color: red;\n}\n\n.my-selector {\n  @extend .red;\n  @extend .blue;\n}\n```\n\nVous imaginez que `.blue` étant appliqué après dans `.my-selector`, il va prendre la priorité. EH BAH NON, c'est `.red`, parce que sa déclaration est située après `.blue`.\n\nSi ce constat peut aussi permettre à ceux et celles qui utilisent des CSS atomiques d'arrêter immédiatement :\n\n```css\n.relative { position: relative; }\n.absolute { position: absolute; }\n.static { position: static; }\n```\n\nDans le cas précédent, si vous ajoutez une classe `relative` à un élement ayant déjà la classe `static`, ça ne changera rien du tout, parce que `.static` est défini après `.relative`. Génial, non ?\n\n### Le futur de CSS\n\nLes variables sont une feature qui a été très demandée à CSS. Mais cette feature va débarquer avec son lot de souci :\n\n```css\n:root {\n  --mainColor: blue;\n}\n\nbody {\n  color: var(--mainColor);\n}\n```\n\nC'est super, mais si quelqu'un vient ajouter :\n\n```css\n:root {\n  --mainColor: red;\n}\n```\n\nquelque part, il y a deux cas :\n\n- soit c'est chargé avant, et ça ne fait rien\n- soit c'est chargé après, et ça override toutes les propriétés utilisant `--mainColor`. On est bien contents.\n\n## Vous ne pouvez pas vous permettre de laisser tomber CSS ?\n\nDans ce cas, forcez vous à utiliser la [méthodologie BEM](/fr/articles/css/bem/). Ça ne réglera pas tout, mais au moins cela vous permettra d'éviter un maximum de conneries en vous forçant à découper en composants isolés, et à mieux maîtriser la priorisation, puisque le scope auquel vous devrez y veiller sera considérablement réduit :\n\n```css\n/* Header.css */\n.Header {}\n\n  .Header-nav {}\n\n/* Nav.css */\n.Nav {}\n\n  .Nav-item {}\n\n    .Nav-item--active {}\n```\n\nC'est quand même plus pratique à comprendre, non ?\n\nEncore mieux, si vous avez du tooling à la webpack, vous pouvez utiliser les [CSS modules](/fr/articles/css/modules/), qui limiteront de même le scope d'application de vos feuilles de style.\n\n## Vous pouvez vous permettre de laisser tomber CSS ?\n\nJavaScript vous permet déjà de bénéficier d'un système de modules, de variables, de conditions, de fonctions réutilisables, et tout ça sans hack. En plus de ça, vous maitrisez la priorisation, parce c'est que c'est vous qui décidez ce qui s'applique :\n\n```javascript\nclass MyComponent extends React.Component {\n  render() {\n    const { active, disabled } = this.props\n    return (\n      <div\n        style={{\n          ...styles.myComponent,\n          ...active ? styles.active : null,\n          ...disabled && !active ? styles.disabled : null,\n        }}\n      >\n        tadaa\n      </div>\n    )\n  }\n}\n\nconst styles = {\n  myComponent: {\n    fontSize: 18,\n  },\n  active: {\n    textDecoration: \"underline\",\n  },\n  disabled: {\n    opacity: 0.5,\n  },\n}\n```\n\nPar ailleurs, avec certaines bibliothèques permettant naturellement l'usage d'inline-styles (comme React), cela vous donne la possibilité d'avoir le style et le markup dans le même fichier, sans avoir besoin de naviguer entre les onglets de votre éditeur (vous pouvez cependant séparer en plusieurs fichiers si ça vous fait plaisir).\n\nEn résumé, utiliser JS pour définir et appliquer les styles vous permet de prendre le contrôle sur le styling de vos composants, tout en apportant le confort d'un langage offrant naturellement de nombreux avantages. Si vous êtes bloqués avec CSS, partez sur les CSS modules ou la méthologie BEM selon vos possibilités. Le but, c'est d'éliminer les [7 maux de CSS](https://github.com/necolas/react-native-web/blob/master/docs/guides/style.md).\n\nBisous bisous.\n","raw":"---\ndate: \"2016-06-16\"\ntitle: Pourquoi j'ai arrêté d'utiliser CSS\ntags:\n  - css\n  - style-inline\n  - javascript\nauthors:\n  - bloodyowl\n---\n\nCSS est un langage horriblement dangereux, parce qu'il mêle des concepts complètement pétés et une folle capacité à faire confondre facilité et simplicité aux gens qui l'utilisent.\n\n## Qu'est-ce qui ne va pas ?\n\nÀ l'origine, CSS a été conçu pour styler des documents, pas des applications. Du coup lorsqu'on doit *scale*, c'est rapidement douloureux.\n\n### Les sélecteurs\n\nLes sélecteurs sont des **variables globales mutables**. Lorsque vous faites :\n\n```css\n.selector {\n  font-size: 1rem;\n}\n```\n\nC'est comme si en JavaScript vous faisiez :\n\n```javascript\nwindow.selector = (window.selector || []).concat({\n  fontSize: \"1rem\",\n})\n```\n\nÇa veut dire que :\n\n- La définition d'un style associé à un sélecteur peut être redéfinie ailleurs\n- Si on associe plusieurs styles à un sélecteur, les derniers définis dans le CSS auront toujours la priorité\n- Quelqu'un peut péter les styles d'un composant pour peu qu'il ne sache pas qu'un sélecteur est utilisé ailleurs\n\n### La spécificité\n\nAlors ça, c'est particulièrement drôle : la spécificité d'un sélecteur va définir la priorité d'application d'un style.\n\n| Sélecteur | Spécificité |\n| --- | --- |\n| `*` | 0,0,0,0 |\n| `li` | 0,0,0,1 |\n| `li:first-line` | 0,0,0,2 |\n| `ul li` | 0,0,0,2 |\n| `ul ol+li` | 0,0,0,3 |\n| `h1 + *[rel=up]` | 0,0,1,1 |\n| `ul ol li.red` | 0,0,1,3 |\n| `li.red.level` | 0,0,2,1 |\n| `#x34y` | 0,1,0,0 |\n\nSi le style est défini dans l'attribut `style`, la spécificité est de 1,0,0,0. Si une valeur associée à une propriété est suffixée d'un `!important`, elle prend quoi qu'il arrive l'ascendance.\n\nSi on résume, on nage en plein délire, la priorité se définit dans l'ordre par : la présence de `!important`, la façon de définir le style, la spécificité du sélecteur utilisé puis par l'ordre de définition dans l'ensemble des CSS de la page. Évidemment, à l'époque où on n'avait qu'une pauvre petite feuille de style pour l'ensemble de son site, ça marchait ; plus maintenant.\n\n### Les régressions\n\nPrenons un exemple tout bête :\n\n```css\n.item {\n  display: block;\n  font-size: 1rem;\n  color: blue;\n}\n\n.some-context .item {\n  display: inline-block;\n  color: red;\n}\n```\n\nQuelqu'un de la team modifie `.item` :\n\n```diff\n .item {\n   display: block;\n   font-size: 1rem;\n   color: blue;\n+  border: 1px solid red;\n }\n\n .some-context .item {\n   display: inline-block;\n   color: red;\n}\n```\n\nSuper, une regression dans `some-context`. Face à ça, deux possibilités :\n\n- Vous vous foutez d'avoir des régressions qui pètent votre site\n- À chaque changement minime du CSS vous vérifiez l'intégralité du site et testez tous les comportements dans tous les contextes.\n\n### Le choix de priorisation des styles\n\nCe serait pas mal de décider quel `className` est appliqué en priorité :\n\n```html\n<div class=\"blue red\">text</div>\n<div class=\"red blue\">text</div>\n```\n\nmais bien évidemment non, comme vu plus haut, c'est le foutu ordre de définition des sélecteurs qui décide. Je vous laisse imaginer le bordel si on charge les feuilles de style à la demande, selon les actions utilisateur.\n\n```css\n.blue { color: blue; }\n.red { color: red; }\n```\n\nC'est pire si vous utilisez un préprocesseur tel que Sass et LESS. Lorsque vous faites un :\n\n```css\n.blue {\n  color: blue;\n}\n\n.red {\n  color: red;\n}\n\n.my-selector {\n  @extend .red;\n  @extend .blue;\n}\n```\n\nVous imaginez que `.blue` étant appliqué après dans `.my-selector`, il va prendre la priorité. EH BAH NON, c'est `.red`, parce que sa déclaration est située après `.blue`.\n\nSi ce constat peut aussi permettre à ceux et celles qui utilisent des CSS atomiques d'arrêter immédiatement :\n\n```css\n.relative { position: relative; }\n.absolute { position: absolute; }\n.static { position: static; }\n```\n\nDans le cas précédent, si vous ajoutez une classe `relative` à un élement ayant déjà la classe `static`, ça ne changera rien du tout, parce que `.static` est défini après `.relative`. Génial, non ?\n\n### Le futur de CSS\n\nLes variables sont une feature qui a été très demandée à CSS. Mais cette feature va débarquer avec son lot de souci :\n\n```css\n:root {\n  --mainColor: blue;\n}\n\nbody {\n  color: var(--mainColor);\n}\n```\n\nC'est super, mais si quelqu'un vient ajouter :\n\n```css\n:root {\n  --mainColor: red;\n}\n```\n\nquelque part, il y a deux cas :\n\n- soit c'est chargé avant, et ça ne fait rien\n- soit c'est chargé après, et ça override toutes les propriétés utilisant `--mainColor`. On est bien contents.\n\n## Vous ne pouvez pas vous permettre de laisser tomber CSS ?\n\nDans ce cas, forcez vous à utiliser la [méthodologie BEM](/fr/articles/css/bem/). Ça ne réglera pas tout, mais au moins cela vous permettra d'éviter un maximum de conneries en vous forçant à découper en composants isolés, et à mieux maîtriser la priorisation, puisque le scope auquel vous devrez y veiller sera considérablement réduit :\n\n```css\n/* Header.css */\n.Header {}\n\n  .Header-nav {}\n\n/* Nav.css */\n.Nav {}\n\n  .Nav-item {}\n\n    .Nav-item--active {}\n```\n\nC'est quand même plus pratique à comprendre, non ?\n\nEncore mieux, si vous avez du tooling à la webpack, vous pouvez utiliser les [CSS modules](/fr/articles/css/modules/), qui limiteront de même le scope d'application de vos feuilles de style.\n\n## Vous pouvez vous permettre de laisser tomber CSS ?\n\nJavaScript vous permet déjà de bénéficier d'un système de modules, de variables, de conditions, de fonctions réutilisables, et tout ça sans hack. En plus de ça, vous maitrisez la priorisation, parce c'est que c'est vous qui décidez ce qui s'applique :\n\n```javascript\nclass MyComponent extends React.Component {\n  render() {\n    const { active, disabled } = this.props\n    return (\n      <div\n        style={{\n          ...styles.myComponent,\n          ...active ? styles.active : null,\n          ...disabled && !active ? styles.disabled : null,\n        }}\n      >\n        tadaa\n      </div>\n    )\n  }\n}\n\nconst styles = {\n  myComponent: {\n    fontSize: 18,\n  },\n  active: {\n    textDecoration: \"underline\",\n  },\n  disabled: {\n    opacity: 0.5,\n  },\n}\n```\n\nPar ailleurs, avec certaines bibliothèques permettant naturellement l'usage d'inline-styles (comme React), cela vous donne la possibilité d'avoir le style et le markup dans le même fichier, sans avoir besoin de naviguer entre les onglets de votre éditeur (vous pouvez cependant séparer en plusieurs fichiers si ça vous fait plaisir).\n\nEn résumé, utiliser JS pour définir et appliquer les styles vous permet de prendre le contrôle sur le styling de vos composants, tout en apportant le confort d'un langage offrant naturellement de nombreux avantages. Si vous êtes bloqués avec CSS, partez sur les CSS modules ou la méthologie BEM selon vos possibilités. Le but, c'est d'éliminer les [7 maux de CSS](https://github.com/necolas/react-native-web/blob/master/docs/guides/style.md).\n\nBisous bisous.\n","__filename":"fr/articles/css/stop-css/index.md","__url":"/fr/articles/css/stop-css/","__resourceUrl":"/fr/articles/css/stop-css/index.html","__dataUrl":"/fr/articles/css/stop-css/index.html.baf5d1bbd2424c1fc95331f6c9a565b9.json"}